{"version":3,"file":"index.umd.js","mappings":"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","sources":["webpack://PservClient/webpack/universalModuleDefinition","webpack://PservClient/webpack/bootstrap","webpack://PservClient/webpack/runtime/define property getters","webpack://PservClient/webpack/runtime/hasOwnProperty shorthand","webpack://PservClient/webpack/runtime/make namespace object","webpack://PservClient/./src/EventTarget.ts","webpack://PservClient/./src/AbstractChatClient.ts","webpack://PservClient/./src/IndexedObjectCollection.ts","webpack://PservClient/./src/state-tracker/AsyncUtils.ts","webpack://PservClient/./src/state-tracker/TopicHistoryWindow.ts","webpack://PservClient/./src/state-tracker/RoomMessagesHistory.ts","webpack://PservClient/./src/state-tracker/MessagesManager.ts","webpack://PservClient/./src/state-tracker/RoomsManager.ts","webpack://PservClient/./src/state-tracker/functions.ts","webpack://PservClient/./src/state-tracker/SpacesManager.ts","webpack://PservClient/./src/Permissions.ts","webpack://PservClient/./src/state-tracker/PermissionsManager.ts","webpack://PservClient/./src/state-tracker/EmoticonsManager.ts","webpack://PservClient/./src/state-tracker/UsersManager.ts","webpack://PservClient/./src/state-tracker/RelationshipsManager.ts","webpack://PservClient/./src/state-tracker/ChatStateTracker.ts","webpack://PservClient/./src/WebSocketChatClient.ts","webpack://PservClient/./src/WebApiChatClient.ts","webpack://PservClient/./src/AbstractRestClient.ts","webpack://PservClient/./src/AuthClient.ts","webpack://PservClient/./src/FilesClient.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PservClient\"] = factory();\n\telse\n\t\troot[\"PservClient\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type EventHandler<EventT> = (ev?: EventT) => void;\r\ntype HandlersMap<EventT> = Map<string, EventHandler<EventT>[]>;\r\n\r\nexport interface ObservableInterface<EventT = any> {\r\n    on(eventName: string, handler: EventHandler<EventT>): this;\r\n    once(eventName: string, handler: EventHandler<EventT>): this;\r\n    off(eventName: string, handler: EventHandler<EventT>): this;\r\n}\r\n\r\nexport class EventTarget<EventT = any> implements ObservableInterface<EventT> {\r\n    protected events: HandlersMap<EventT> = new Map<string, EventHandler<EventT>[]>();\r\n    protected onceEvents: HandlersMap<EventT> = new Map<string, EventHandler<EventT>[]>();\r\n\r\n    public on(eventName: string, handler: EventHandler<EventT>): this {\r\n        this.addHandler(this.events, eventName, handler);\r\n        return this;\r\n    }\r\n\r\n    public once(eventName: string, handler: EventHandler<EventT>): this {\r\n        this.addHandler(this.onceEvents, eventName, handler);\r\n        return this;\r\n    }\r\n\r\n    public off(eventName: string, handler: EventHandler<EventT>): this {\r\n        const index = this.events.get(eventName)?.indexOf(handler);\r\n        if (!index || index < 0) {\r\n            return this;\r\n        }\r\n        this.events.get(eventName).splice(index, 1);\r\n        return this;\r\n    }\r\n\r\n    public emit(eventName: string, event?: EventT): this {\r\n        this.callHandlers(this.events, eventName, event);\r\n        this.callHandlers(this.onceEvents, eventName, event);\r\n        this.onceEvents.delete(eventName);\r\n        return this;\r\n    }\r\n\r\n    private addHandler(map: HandlersMap<EventT>, eventName: string, handler: EventHandler<EventT>): void {\r\n        const handlers = map.get(eventName) ?? [];\r\n        handlers.push(handler);\r\n        map.set(eventName, handlers);\r\n    }\r\n\r\n    private callHandlers(map: HandlersMap<EventT>, eventName: string, event: EventT): void {\r\n        map.get(eventName)?.forEach(callback => callback(event));\r\n    }\r\n}","import {\r\n    Bye,\r\n    GetSession,\r\n    JoinSpace,\r\n    Session,\r\n    SpaceJoined,\r\n    Error as ErrorType,\r\n    SpaceLeft,\r\n    SpaceMemberJoined,\r\n    SpaceMemberLeft,\r\n    SpaceMemberUpdated,\r\n    SpaceDeleted,\r\n    SpaceMembers,\r\n    SpaceRooms,\r\n    NewRole,\r\n    RoomDeleted,\r\n    RoomJoined,\r\n    RoomLeft,\r\n    RoomMemberLeft,\r\n    RoomMemberJoined,\r\n    RoomMembers,\r\n    NewRoom,\r\n    NewTopic,\r\n    TopicDeleted,\r\n    NewMessage,\r\n    GetPermissionOverwrites,\r\n    GetComputedPermissions,\r\n    LeaveSpace,\r\n    CreateSpace,\r\n    DeleteSpace,\r\n    GetSpaceMembers,\r\n    GetSpaceRooms,\r\n    CreateRole,\r\n    DeleteRole,\r\n    AssignRole,\r\n    DeassignRole,\r\n    SetPermissionOverwrites,\r\n    JoinRoom,\r\n    LeaveRoom,\r\n    CreateRoom,\r\n    DeleteRoom,\r\n    GetRoomMembers,\r\n    CreateTopic,\r\n    DeleteTopic,\r\n    CreateMessage,\r\n    Envelope,\r\n    PermissionOverwrites,\r\n    PermissionOverwritesUpdated,\r\n    RoomMemberUpdated,\r\n    UpdateRole,\r\n    RoleUpdated,\r\n    Ack,\r\n    UserUpdated,\r\n    UpdateRoom,\r\n    RoomUpdated,\r\n    UpdateSpace,\r\n    SpaceUpdated,\r\n    PermissionOverwriteTargets,\r\n    GetPermissionOverwriteTargets,\r\n    Owners,\r\n    Ok,\r\n    GetOwners,\r\n    CreateOwner,\r\n    RoleDeleted,\r\n    FollowedTopicUpdated,\r\n    TopicFollowed,\r\n    TopicUnfollowed,\r\n    FollowedTopics,\r\n    FollowTopic,\r\n    UnfollowTopic,\r\n    GetFollowedTopics,\r\n    Messages,\r\n    GetMessages,\r\n    Topics,\r\n    GetTopics,\r\n    TopicUpdated,\r\n    UpdateTopic,\r\n    GetDiscoverableSpaces,\r\n    DiscoverableSpaces,\r\n    CreateEmoticon,\r\n    DeleteEmoticon,\r\n    GetEmoticons,\r\n    Emoticons,\r\n    EmoticonDeleted,\r\n    NewEmoticon,\r\n    Bans,\r\n    GetBans,\r\n    Ban,\r\n    Unban,\r\n    Kick,\r\n    ClientData,\r\n    GetClientData,\r\n    SetClientData,\r\n    GetRoomSummary,\r\n    GetSpaceSummary,\r\n    RoomSummaryEvent,\r\n    SpaceSummaryEvent,\r\n    SetCustomNick,\r\n    Relationships,\r\n    RelationshipDeleted,\r\n    NewRelationship,\r\n    DeleteRelationship,\r\n    CreateRelationship,\r\n    RoomSummaryUpdated,\r\n} from \"./types/src/index\";\r\nimport {EventTarget} from \"./EventTarget\";\r\nimport {GetRelationships} from \"./types/src/schemes/commands/GetRelationships\";\r\n\r\ntype ArrayOfPromiseResolvers = [(value: any) => void, (reason?: any) => void];\r\n\r\nexport abstract class AbstractChatClient extends EventTarget {\r\n    protected awaitingResponse: Map<string, ArrayOfPromiseResolvers> = new Map<string, ArrayOfPromiseResolvers>();\r\n    protected sentCounter: number = 0;\r\n\r\n    public abstract send<CommandType extends keyof CommandsMap>\r\n        (commandType: CommandType, commandData: CommandsMap[CommandType][0]): Promise<CommandResult<CommandsMap[CommandType][1]>>;\r\n\r\n    public on<EventName extends keyof EventsMap>\r\n        (eventName: EventName | string, handler: (event: EventsMap[EventName]) => void): this {\r\n        return super.on(eventName, handler);\r\n    }\r\n\r\n    public once<EventName extends keyof EventsMap>\r\n        (eventName: EventName, handler: (event: EventsMap[EventName]) => void): this {\r\n        return super.once(eventName, handler);\r\n    }\r\n\r\n    protected createEnvelope<CommandT>(type: string, data: CommandT): Envelope<CommandT> {\r\n        return {\r\n            type, data, ref: (++this.sentCounter).toString()\r\n        };\r\n    }\r\n\r\n    protected createPromiseFromCommandEnvelope\r\n        <CommandT extends keyof CommandsMap>(envelope: Envelope<CommandsMap[CommandT][0]>):\r\n        Promise<CommandResult<CommandsMap[CommandT][1]>> {\r\n        return new Promise((...args) =>\r\n            this.awaitingResponse.set(envelope.ref as string, args));\r\n    }\r\n\r\n    protected handleIncomingEnvelope(envelope: Envelope): void {\r\n        if (!this.awaitingResponse.has(envelope.ref)) {\r\n            return;\r\n        }\r\n        const isError = envelope.type === 'Error';\r\n        this.awaitingResponse.get(envelope.ref)[0]({\r\n            data: isError ? null : envelope.data,\r\n            error: isError ? envelope.data : null,\r\n        } as CommandResult<any>);\r\n        this.awaitingResponse.delete(envelope.ref);\r\n    }\r\n\r\n    protected handleEnvelopeSendError(envelope: Envelope, error: any): void {\r\n        if (!this.awaitingResponse.has(envelope.ref)) {\r\n            return;\r\n        }\r\n        this.awaitingResponse.get(envelope.ref)[1](error);\r\n        this.awaitingResponse.delete(envelope.ref);\r\n    }\r\n}\r\n\r\nexport type CommandResult<ResultT> = {data?: ResultT, error?: ErrorType};\r\n\r\n/**\r\n * Map of incoming events.\r\n */\r\nexport type EventsMap = {\r\n    // General Events\r\n    Bye: Bye,\r\n    Ok: Ok,\r\n    Error: ErrorType,\r\n    Session: Session,\r\n    Permissions: Permissions,\r\n    PermissionOverwrites: PermissionOverwrites,\r\n    PermissionOverwritesUpdated: PermissionOverwritesUpdated,\r\n    PermissionOverwriteTargets: PermissionOverwriteTargets,\r\n    Owners: Owners,\r\n    NewEmoticon: NewEmoticon,\r\n    EmoticonDeleted: EmoticonDeleted,\r\n    Emoticons: Emoticons,\r\n    Bans: Bans,\r\n    ClientData: ClientData,\r\n    NewRelationship: NewRelationship,\r\n    RelationshipDeleted: RelationshipDeleted,\r\n    Relationships: Relationships,\r\n    // Space events\r\n    DiscoverableSpaces: DiscoverableSpaces,\r\n    SpaceJoined: SpaceJoined,\r\n    SpaceLeft: SpaceLeft,\r\n    SpaceMemberJoined: SpaceMemberJoined,\r\n    SpaceMemberLeft: SpaceMemberLeft,\r\n    SpaceMemberUpdated: SpaceMemberUpdated,\r\n    SpaceUpdated: SpaceUpdated,\r\n    SpaceDeleted: SpaceDeleted,\r\n    SpaceMembers: SpaceMembers,\r\n    SpaceRooms: SpaceRooms,\r\n    NewRole: NewRole,\r\n    RoleDeleted: RoleDeleted,\r\n    RoleUpdated: RoleUpdated,\r\n    SpaceSummaryEvent: SpaceSummaryEvent,\r\n    // Room events\r\n    RoomJoined: RoomJoined,\r\n    RoomLeft: RoomLeft,\r\n    RoomMemberJoined: RoomMemberJoined,\r\n    RoomMemberLeft: RoomMemberLeft,\r\n    RoomMemberUpdated: RoomMemberUpdated,\r\n    RoomMembers: RoomMembers,\r\n    NewRoom: NewRoom,\r\n    RoomDeleted: RoomDeleted,\r\n    RoomUpdated: RoomUpdated,\r\n    RoomSummaryEvent: RoomSummaryEvent,\r\n    RoomSummaryUpdated: RoomSummaryUpdated,\r\n    // Topic events\r\n    NewTopic: NewTopic,\r\n    TopicDeleted: TopicDeleted,\r\n    NewMessage: NewMessage,\r\n    UserUpdated: UserUpdated,\r\n    TopicFollowed: TopicFollowed,\r\n    TopicUnfollowed: TopicUnfollowed,\r\n    FollowedTopics: FollowedTopics,\r\n    FollowedTopicUpdated: FollowedTopicUpdated,\r\n    Messages: Messages,\r\n    Topics: Topics,\r\n    TopicUpdated: TopicUpdated,\r\n};\r\n\r\n/**\r\n * Map of commands and their corresponding events.\r\n */\r\nexport type CommandsMap = {\r\n    // General commands\r\n    GetSession: [GetSession, EventsMap['Session']],\r\n    SetPermissionOverwrites: [SetPermissionOverwrites, EventsMap['PermissionOverwritesUpdated']],\r\n    GetPermissionOverwrites: [GetPermissionOverwrites, EventsMap['PermissionOverwrites']],\r\n    GetComputedPermissions: [GetComputedPermissions, EventsMap['Permissions']],\r\n    GetPermissionOverwriteTargets: [GetPermissionOverwriteTargets, EventsMap['PermissionOverwriteTargets']],\r\n    GetOwners: [GetOwners, EventsMap['Owners']],\r\n    CreateOwner: [CreateOwner, EventsMap['Owners']],\r\n    DeleteOwner: [CreateOwner, EventsMap['Owners']],\r\n    CreateEmoticon: [CreateEmoticon, EventsMap['NewEmoticon']],\r\n    DeleteEmoticon: [DeleteEmoticon, EventsMap['EmoticonDeleted']],\r\n    GetEmoticons: [GetEmoticons, EventsMap['Emoticons']],\r\n    GetBans: [GetBans, EventsMap['Bans']],\r\n    Ban: [Ban, EventsMap['Ok']],\r\n    Unban: [Unban, EventsMap['Ok']],\r\n    Kick: [Kick, EventsMap['Ok']],\r\n    GetClientData: [GetClientData, EventsMap['ClientData']],\r\n    SetClientData: [SetClientData, EventsMap['Ok']],\r\n    DeleteRelationship: [DeleteRelationship, EventsMap['RelationshipDeleted']],\r\n    CreateRelationship: [CreateRelationship, EventsMap['NewRelationship']],\r\n    GetRelationships: [GetRelationships, EventsMap['Relationships']],\r\n    // Space commands\r\n    GetDiscoverableSpaces: [GetDiscoverableSpaces, EventsMap['DiscoverableSpaces']],\r\n    JoinSpace: [JoinSpace, EventsMap['SpaceJoined']],\r\n    LeaveSpace: [LeaveSpace, EventsMap['SpaceLeft']],\r\n    CreateSpace: [CreateSpace, EventsMap['SpaceJoined']],\r\n    UpdateSpace: [UpdateSpace, EventsMap['SpaceUpdated']],\r\n    DeleteSpace: [DeleteSpace, EventsMap['SpaceDeleted']],\r\n    GetSpaceMembers: [GetSpaceMembers, EventsMap['SpaceMembers']],\r\n    GetSpaceRooms: [GetSpaceRooms, EventsMap['SpaceRooms']],\r\n    CreateRole: [CreateRole, EventsMap['NewRole']],\r\n    DeleteRole: [DeleteRole, EventsMap['RoleDeleted']],\r\n    UpdateRole: [UpdateRole, EventsMap['RoleUpdated']],\r\n    AssignRole: [AssignRole, EventsMap['SpaceMemberUpdated'] | EventsMap['RoomMemberUpdated']],\r\n    DeassignRole: [DeassignRole, EventsMap['SpaceMemberUpdated'] | EventsMap['RoomMemberUpdated']],\r\n    GetSpaceSummary: [GetSpaceSummary, EventsMap['SpaceSummaryEvent']],\r\n    SetCustomNick: [SetCustomNick, EventsMap['SpaceMemberUpdated']],\r\n    // Room commands\r\n    JoinRoom: [JoinRoom, EventsMap['RoomJoined']],\r\n    LeaveRoom: [LeaveRoom, EventsMap['RoomLeft']],\r\n    CreateRoom: [CreateRoom, EventsMap['RoomJoined']],\r\n    DeleteRoom: [DeleteRoom, EventsMap['RoomDeleted']],\r\n    UpdateRoom: [UpdateRoom, EventsMap['RoomUpdated']],\r\n    GetRoomMembers: [GetRoomMembers, EventsMap['RoomMembers']],\r\n    GetRoomSummary: [GetRoomSummary, EventsMap['RoomSummaryEvent']],\r\n    // Topic commands\r\n    CreateTopic: [CreateTopic, EventsMap['NewTopic']],\r\n    DeleteTopic: [DeleteTopic, EventsMap['TopicDeleted']],\r\n    CreateMessage: [CreateMessage, EventsMap['NewMessage']],\r\n    Ack: [Ack, EventsMap['FollowedTopicUpdated'] | EventsMap['Ok']],\r\n    FollowTopic: [FollowTopic, EventsMap['TopicFollowed']],\r\n    UnfollowTopic: [UnfollowTopic, EventsMap['TopicUnfollowed']],\r\n    GetFollowedTopics: [GetFollowedTopics, EventsMap['FollowedTopics']],\r\n    GetMessages: [GetMessages, EventsMap['Messages']],\r\n    GetTopics: [GetTopics, EventsMap['Topics']],\r\n    UpdateTopic: [UpdateTopic, EventsMap['TopicUpdated']],\r\n}","import {EventTarget, ObservableInterface} from \"./EventTarget\";\r\n\r\nexport class IndexedCollection<KeyT, ValueT> {\r\n    protected _items: Map<KeyT, ValueT> = new Map();\r\n\r\n    public constructor(items: [key: KeyT, value: ValueT][] = []) {\r\n        this.set(...items);\r\n    }\r\n\r\n    public get items(): Map<KeyT, ValueT> {\r\n        return this._items;\r\n    }\r\n\r\n    public get length(): number {\r\n        return this._items.size;\r\n    }\r\n\r\n    public set(...items: [KeyT, ValueT][]): void {\r\n        for (const item of items) {\r\n            this._items.set(item[0], item[1]);\r\n        }\r\n    }\r\n\r\n    public get(id: KeyT): ValueT | undefined {\r\n        return this.items.get(id);\r\n    }\r\n\r\n    public has(id: KeyT): boolean {\r\n        return this.items.has(id);\r\n    }\r\n\r\n    public delete(...ids: KeyT[]): void {\r\n        for (const id of ids) {\r\n            this.items.delete(id);\r\n        }\r\n    }\r\n\r\n    public deleteAll(): void {\r\n        this.items.clear();\r\n    }\r\n\r\n    public findBy(field: keyof ValueT, valueToFind: any, limit: number = null): IndexedCollection<KeyT, ValueT> {\r\n        const result = new IndexedCollection<KeyT, ValueT>();\r\n        let item;\r\n        while (!(item = this.items.entries().next().value).done) {\r\n            if (limit && result.length === limit) {\r\n                break;\r\n            }\r\n            if (item[1][field] === valueToFind) {\r\n                result.set(item);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public shallowCopy(): IndexedCollection<KeyT, ValueT> {\r\n        const copy = new IndexedCollection<KeyT, ValueT>();\r\n        copy._items = this._items;\r\n        return copy;\r\n    }\r\n}\r\n\r\nexport class IndexedObjectCollection<T> {\r\n    protected _items: IndexedCollection<string, T>;\r\n\r\n    public constructor(\r\n        public readonly id: keyof T | ((item: T) => any),\r\n        items: T[] = [],\r\n    ) {\r\n        this._items = new IndexedCollection<string, T>();\r\n        this.set(...items);\r\n    }\r\n\r\n    public get items(): T[] {\r\n        return Array.from(this._items.items.values());\r\n    }\r\n\r\n    public get length(): number {\r\n        return this._items.length;\r\n    }\r\n\r\n    public set(...items: T[]): void {\r\n        this._items.set(...(items.map(item => [this.getId(item), item] as [string, T])));\r\n    }\r\n\r\n    public get(id: any): T | undefined {\r\n        return this._items.get(id);\r\n    }\r\n\r\n    public getAt(index: number): T | undefined {\r\n        return this.items[index];\r\n    }\r\n\r\n    public has(id: any): boolean {\r\n        return this._items.has(id);\r\n    }\r\n\r\n    public delete(...ids: any[]): void {\r\n        this._items.delete(...ids);\r\n    }\r\n\r\n    public deleteAll(): void {\r\n        this._items.deleteAll();\r\n    }\r\n\r\n    public findBy(field: keyof T, valueToFind: any, limit: number = null): IndexedObjectCollection<T> {\r\n        const result = new IndexedObjectCollection<T>(this.id);\r\n        for (const value of this.items) {\r\n            if (limit && result.length === limit) {\r\n                break;\r\n            }\r\n            if (value[field] === valueToFind) {\r\n                result.set(value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public shallowCopy(): IndexedObjectCollection<T> {\r\n        const copy = new IndexedObjectCollection<T>(this.id);\r\n        copy._items = this._items;\r\n        return copy;\r\n    }\r\n\r\n    protected getId(item: T): any {\r\n        return typeof this.id === 'function' ? this.id(item) : item[this.id];\r\n    }\r\n}\r\n\r\ninterface ObservableCollectionEvent<KeyT> {\r\n    setItems?: KeyT[],\r\n    deletedItems?: KeyT[],\r\n}\r\n\r\nexport class ObservableIndexedCollection<KeyT, ValueT> extends IndexedCollection<KeyT, ValueT> implements ObservableInterface {\r\n    protected eventTarget: EventTarget<ObservableCollectionEvent<KeyT>>;\r\n\r\n    public constructor(items: [key: KeyT, value: ValueT][] = []) {\r\n        super();\r\n        this.eventTarget = new EventTarget<ObservableCollectionEvent<KeyT>>();\r\n        this.set(...items);\r\n    }\r\n\r\n    public set(...items: [KeyT, ValueT][]) {\r\n        if (items.length) {\r\n            super.set(...items);\r\n            this.eventTarget.emit('change', {setItems: items.map(item => item[0])});\r\n        }\r\n    }\r\n\r\n    public delete(...ids: KeyT[]) {\r\n        if (ids.length) {\r\n            super.delete(...ids);\r\n            this.eventTarget.emit('change', {deletedItems: ids});\r\n        }\r\n    }\r\n\r\n    public deleteAll() {\r\n        if (this.length) {\r\n            const ids = this._items.keys();\r\n            super.deleteAll();\r\n            this.eventTarget.emit('change', {deletedItems: Array.from(ids)});\r\n        }\r\n    }\r\n\r\n    public shallowCopy(): ObservableIndexedCollection<KeyT, ValueT> {\r\n        const copy = new ObservableIndexedCollection<KeyT, ValueT>();\r\n        copy.eventTarget = this.eventTarget;\r\n        copy._items = this._items;\r\n        return copy;\r\n    }\r\n\r\n    public on(eventName: 'change', handler: (ev?: ObservableCollectionEvent<KeyT>) => void): this {\r\n        this.eventTarget.on(eventName, handler);\r\n        return this;\r\n    }\r\n\r\n    public once(eventName: 'change', handler: (ev?: ObservableCollectionEvent<KeyT>) => void): this {\r\n        this.eventTarget.once(eventName, handler);\r\n        return this;\r\n    }\r\n\r\n    public off(eventName: string, handler: (ev?: ObservableCollectionEvent<KeyT>) => void): this {\r\n        this.eventTarget.off(eventName, handler);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class ObservableIndexedObjectCollection<T> extends IndexedObjectCollection<T> implements ObservableInterface {\r\n    protected eventTarget: EventTarget<ObservableCollectionEvent<string>>;\r\n\r\n    public constructor(\r\n        public readonly id: keyof T | ((item: T) => string),\r\n        items: T[] = [],\r\n    ) {\r\n        super(id);\r\n        this.eventTarget = new EventTarget();\r\n        this.set(...items);\r\n    }\r\n\r\n    public set(...items: T[]) {\r\n        if (items.length) {\r\n            super.set(...items);\r\n            this.eventTarget.emit('change', {setItems: items.map(item => this.getId(item))});\r\n        }\r\n    }\r\n\r\n    public delete(...ids: string[]) {\r\n        if (ids.length) {\r\n            super.delete(...ids);\r\n            this.eventTarget.emit('change', {deletedItems: ids});\r\n        }\r\n    }\r\n\r\n    public deleteAll() {\r\n        if (this.length) {\r\n            const ids = this._items.items.keys();\r\n            super.deleteAll();\r\n            this.eventTarget.emit('change', {deletedItems: Array.from(ids)});\r\n        }\r\n    }\r\n\r\n    public shallowCopy(): IndexedObjectCollection<T> {\r\n        const copy = new ObservableIndexedObjectCollection<T>(this.id);\r\n        copy.eventTarget = this.eventTarget;\r\n        copy._items = this._items;\r\n        return copy;\r\n    }\r\n\r\n    public on(eventName: 'change', handler: (ev?: ObservableCollectionEvent<string>) => void): this {\r\n        this.eventTarget.on(eventName, handler);\r\n        return this;\r\n    }\r\n\r\n    public once(eventName: 'change', handler: (ev?: ObservableCollectionEvent<string>) => void): this {\r\n        this.eventTarget.once(eventName, handler);\r\n        return this;\r\n    }\r\n\r\n    public off(eventName: string, handler: (ev?: ObservableCollectionEvent<string>) => void): this {\r\n        this.eventTarget.off(eventName, handler);\r\n        return this;\r\n    }\r\n}","import {IndexedCollection} from \"../IndexedObjectCollection\";\r\n\r\nexport class DeferredTask {\r\n    public readonly promise: Promise<void>;\r\n    public resolve: () => void;\r\n\r\n    public constructor() {\r\n        this.promise = new Promise<void>((resolve) => this.resolve = resolve);\r\n    }\r\n}\r\n\r\nexport class PromiseRegistry {\r\n    private promises = new IndexedCollection<string, Promise<any>>();\r\n\r\n    public register<T = any>(promise: Promise<T>, key: string): void {\r\n        this.promises.set([key, promise]);\r\n    }\r\n\r\n    public registerByFunction(fn: () => Promise<any>, key: string): void {\r\n        this.register(fn(), key);\r\n    }\r\n\r\n    public get<T = any>(key: string): Promise<T> | undefined {\r\n        return this.promises.get(key);\r\n    }\r\n\r\n    public has(key: string): boolean {\r\n        return this.promises.has(key);\r\n    }\r\n\r\n    public notExist(key: string): boolean {\r\n        return ! this.has(key);\r\n    }\r\n\r\n    public forget(...keys: string[]): void {\r\n        this.promises.delete(...keys);\r\n    }\r\n\r\n    public forgetAll(): void {\r\n        this.promises.deleteAll();\r\n    }\r\n}","import {Message, NewMessage, Session, Topic} from \"../types/src\";\r\nimport {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {ObservableIndexedObjectCollection} from \"../IndexedObjectCollection\";\r\n\r\nexport enum WindowState {\r\n    /**\r\n     * The latest messages (those received live) are available in the history window, history has not been fetched.\r\n     */\r\n    LIVE,\r\n\r\n    /**\r\n     * The latest messages has been fetched and are available in the history window.\r\n     */\r\n    LATEST,\r\n\r\n    /**\r\n     * The historical messages have been fetched and are available in the history window.\r\n     * Latest messages are not available and will not be available.\r\n     */\r\n    PAST,\r\n\r\n    /**\r\n     * The oldest messages have been fetched and are available in the history window.\r\n     * Next attempts to fetch previous messages will result with no-op.\r\n     */\r\n    OLDEST,\r\n}\r\n\r\nexport abstract class TraversableRemoteCollection<T> extends ObservableIndexedObjectCollection<T> {\r\n    /**\r\n     * Current mode od collection window. To change mode, call one of available fetch methods.\r\n     */\r\n    public get state(): WindowState {\r\n        return this.currentState;\r\n    }\r\n\r\n    /**\r\n     * Maximum numer of items stored in window.\r\n     * Null for unlimited.\r\n     */\r\n    public limit: number | null = 50;\r\n\r\n    private currentState: WindowState = WindowState.LIVE;\r\n    private fetchingState: WindowState = undefined;\r\n    public oldestId: string = null;\r\n\r\n    public get hasLatest(): boolean {\r\n        return [WindowState.LATEST, WindowState.LIVE].includes(this.state);\r\n    }\r\n\r\n    public get hasOldest(): boolean {\r\n        return this.state === WindowState.OLDEST || this.oldestId !== null && this.has(this.oldestId);\r\n    }\r\n\r\n    public async resetToLatest(): Promise<void> {\r\n        if (this.fetchingState || this.currentState === WindowState.LATEST) {\r\n            return;\r\n        }\r\n\r\n        this.fetchingState = WindowState.LATEST;\r\n\r\n        let result;\r\n\r\n        try {\r\n            result = await this.fetchLatestItems();\r\n        } finally {\r\n            this.fetchingState = undefined;\r\n        }\r\n\r\n        this.deleteAll();\r\n        this.addItems(result, 'tail');\r\n        this.currentState = WindowState.LATEST;\r\n    }\r\n\r\n    public async fetchPrevious(): Promise<void> {\r\n        if (this.fetchingState || this.hasOldest) {\r\n            return;\r\n        }\r\n\r\n        this.fetchingState = WindowState.PAST;\r\n\r\n        let result;\r\n\r\n        try {\r\n            result = await this.fetchItemsBefore();\r\n        } finally {\r\n            this.fetchingState = undefined;\r\n        }\r\n\r\n        if (! result) {\r\n            return this.resetToLatest();\r\n        }\r\n\r\n        if (! result.length) {\r\n            const firstItem = this.getAt(0);\r\n            this.oldestId = firstItem ? this.getId(firstItem) : null;\r\n\r\n            await this.refreshFetchedState();\r\n\r\n            // LATEST state has priority over OLDEST\r\n            if (this.currentState === WindowState.PAST) {\r\n                this.currentState = WindowState.OLDEST;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.addItems(result, 'head');\r\n        await this.refreshFetchedState();\r\n    }\r\n\r\n    public async fetchNext(): Promise<void> {\r\n        if (this.fetchingState || this.hasLatest) {\r\n            return;\r\n        }\r\n\r\n        this.fetchingState = WindowState.PAST;\r\n\r\n        let result;\r\n\r\n        try {\r\n            result = await this.fetchItemsAfter();\r\n        } finally {\r\n            this.fetchingState = undefined;\r\n        }\r\n\r\n        if (! result) {\r\n            await this.resetToLatest();\r\n            return;\r\n        }\r\n\r\n        if (result.length) {\r\n            this.addItems(result, 'tail');\r\n            await this.refreshFetchedState();\r\n            return;\r\n        }\r\n    }\r\n\r\n    protected abstract fetchLatestItems(): Promise<T[]>;\r\n\r\n    protected abstract fetchItemsBefore(): Promise<T[] | null>;\r\n\r\n    protected abstract fetchItemsAfter(): Promise<T[] | null>;\r\n\r\n    protected abstract isLatestItemLoaded(): Promise<boolean>;\r\n\r\n    protected async refreshFetchedState(): Promise<void> {\r\n        this.currentState = (await this.isLatestItemLoaded()) ? WindowState.LATEST : WindowState.PAST;\r\n    }\r\n\r\n    protected addItems(newItems: T[], to: 'head' | 'tail'): void {\r\n        let result;\r\n\r\n        if (to === 'head') {\r\n            result = this.trimItemsArrayToLimit([...newItems, ...this.items], 'tail');\r\n        }\r\n\r\n        if (to === 'tail') {\r\n            result = this.trimItemsArrayToLimit([...this.items, ...newItems], 'head');\r\n        }\r\n\r\n        this.deleteAll();\r\n        this.set(...result);\r\n    }\r\n\r\n    /**\r\n     * Return array with messages of count that matching limit.\r\n     */\r\n    private trimItemsArrayToLimit(items: T[], from: 'head' | 'tail'): T[] {\r\n        if (this.limit === null) {\r\n            return items;\r\n        }\r\n\r\n        if (from === 'head') {\r\n            return items.slice(-this.limit);\r\n        }\r\n\r\n        if (from === 'tail') {\r\n            return items.slice(0, this.limit);\r\n        }\r\n    }\r\n}\r\n\r\nexport class TopicHistoryWindow extends TraversableRemoteCollection<Message> {\r\n    /**\r\n     * Reexported available window modes enum.\r\n     */\r\n    public readonly WindowState: typeof WindowState = WindowState;\r\n\r\n    private traverseLock: boolean = false;\r\n\r\n    public constructor(\r\n        private roomId: string,\r\n        private topicId: string,\r\n        private tracker: ChatStateTracker,\r\n    ) {\r\n        super('id');\r\n        this.tracker.client.on('Session', ev => this.handleSession(ev));\r\n        this.tracker.client.on('NewMessage', ev => this.handleNewMessage(ev));\r\n    }\r\n\r\n    public get isTraverseLocked(): boolean {\r\n        return this.traverseLock;\r\n    }\r\n\r\n    public async setTraverseLock(lock: boolean): Promise<void> {\r\n        this.traverseLock = lock;\r\n\r\n        if (lock && (this.state !== WindowState.LIVE && this.state !== WindowState.LATEST)) {\r\n            await super.resetToLatest();\r\n        }\r\n    }\r\n\r\n    public async resetToLatest(): Promise<void> {\r\n        if (this.traverseLock) {\r\n            return;\r\n        }\r\n        return super.resetToLatest();\r\n    }\r\n\r\n    public async fetchNext(): Promise<void> {\r\n        if (this.traverseLock) {\r\n            return;\r\n        }\r\n        return super.fetchNext();\r\n    }\r\n\r\n    public async fetchPrevious(): Promise<void> {\r\n        if (this.traverseLock) {\r\n            return;\r\n        }\r\n        return super.fetchPrevious();\r\n    }\r\n\r\n    /**\r\n     * For internal use.\r\n     * @internal\r\n     */\r\n    public _updateMessageReference(refTopic: Topic): void {\r\n        const refMessage = this.get(refTopic.refMessage.id);\r\n\r\n        if (refMessage) {\r\n            // Update referenced topic ID in message\r\n            this.set({...refMessage, topicRef: refTopic.id});\r\n        }\r\n    }\r\n\r\n    private async handleNewMessage(ev: NewMessage): Promise<void> {\r\n        if (\r\n            [WindowState.LATEST, WindowState.LIVE].includes(this.state)\r\n            && ev.message.location.roomId === this.roomId\r\n            && ev.message.location.topicId === this.topicId\r\n        ) {\r\n            this.addItems([ev.message], 'tail');\r\n        }\r\n    }\r\n\r\n    private handleSession(ev: Session): void {\r\n        const rooms = ev.state.rooms;\r\n\r\n        if (rooms.find(room => room.id === this.roomId)) {\r\n            this.resetToLatest();\r\n        } else {\r\n            this.deleteAll();\r\n        }\r\n    }\r\n\r\n    protected async fetchItemsAfter(): Promise<Message[] | null> {\r\n        const afterId = this.getAt(this.length - 1)?.id;\r\n\r\n        if (! afterId) {\r\n            // If there is no message to refer, fetch latest\r\n            return null;\r\n        }\r\n\r\n        const result = await this.tracker.client.send('GetMessages', {\r\n            location: {roomId: this.roomId, topicId: this.topicId},\r\n            after: afterId,\r\n        });\r\n\r\n        if (result.error) {\r\n            throw new Error(`Cannot fetch messages: ${result.error.message}`);\r\n        }\r\n\r\n        return result.data.messages;\r\n    }\r\n\r\n    protected async fetchItemsBefore(): Promise<Message[] | null> {\r\n        const beforeId = this.getAt(0)?.id;\r\n\r\n        if (! beforeId) {\r\n            // If there is no message to refer, fetch latest\r\n            return null;\r\n        }\r\n\r\n        const result = await this.tracker.client.send('GetMessages', {\r\n            location: {roomId: this.roomId, topicId: this.topicId},\r\n            before: beforeId,\r\n        });\r\n\r\n        if (result.error) {\r\n            throw new Error(`Cannot fetch messages: ${result.error.message}`);\r\n        }\r\n\r\n        return result.data.messages;\r\n    }\r\n\r\n    protected async fetchLatestItems(): Promise<Message[]> {\r\n        const result = await this.tracker.client.send('GetMessages', {\r\n            location: {roomId: this.roomId, topicId: this.topicId},\r\n        });\r\n\r\n        if (result.error) {\r\n            throw new Error(`Cannot fetch messages: ${result.error.message}`);\r\n        }\r\n\r\n        return result.data.messages;\r\n    }\r\n\r\n    private async getTopic(): Promise<Topic | undefined> {\r\n        return (await this.tracker.rooms.getTopics(this.roomId, [this.topicId])).get(this.topicId);\r\n    }\r\n\r\n    private async getLatestMessageId(): Promise<string | undefined> {\r\n        return (await this.getTopic())?.lastMessage?.id;\r\n    }\r\n\r\n    protected async isLatestItemLoaded(): Promise<boolean> {\r\n        const lastMessageId = await this.getLatestMessageId();\r\n        return lastMessageId ? this.has(lastMessageId) : true;\r\n    }\r\n}","import {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {NewTopic, Room, RoomUpdated, Topic, TopicDeleted} from \"../types/src\";\r\nimport {IndexedCollection,} from \"../IndexedObjectCollection\";\r\nimport {TopicHistoryWindow} from \"./TopicHistoryWindow\";\r\n\r\nexport class RoomMessagesHistory {\r\n    private historyWindows = new IndexedCollection<string, TopicHistoryWindow>();\r\n    private traverseLock: boolean = false;\r\n\r\n    public constructor(\r\n        private room: Room,\r\n        private tracker: ChatStateTracker,\r\n    ) {\r\n        this.tracker.client.on('RoomUpdated', ev => this.handleRoomUpdated(ev));\r\n        this.tracker.client.on('NewTopic', ev => this.handleNewTopic(ev));\r\n        this.tracker.client.on('TopicDeleted', ev => this.handleTopicDeleted(ev));\r\n\r\n        this.updateTraverseLock(this.room);\r\n\r\n        if (this.room.defaultTopic) {\r\n            this.createHistoryWindowForTopic(this.room.defaultTopic);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a history window object for the given topic ID, allowing you to view message history.\r\n     */\r\n    public async getMessagesWindow(topicId: string): Promise<TopicHistoryWindow | undefined> {\r\n        let historyWindow = this.historyWindows.get(topicId);\r\n\r\n        if (!historyWindow) {\r\n            const topic = (await this.tracker.rooms.getTopics(this.room.id, [topicId])).get(topicId);\r\n\r\n            if (topic) {\r\n                this.createHistoryWindowForTopic(topic);\r\n            }\r\n        }\r\n\r\n        return this.historyWindows.get(topicId);\r\n    }\r\n\r\n    private async handleRoomUpdated(ev: RoomUpdated): Promise<void> {\r\n        if (this.room.id === ev.room.id) {\r\n            this.room = ev.room;\r\n\r\n            this.updateTraverseLock(ev.room);\r\n\r\n            if (ev.room.defaultTopic) {\r\n                this.createHistoryWindowForTopic(ev.room.defaultTopic);\r\n            }\r\n\r\n            for (const [, window] of Array.from(this.historyWindows.items)) {\r\n                await window.setTraverseLock(this.traverseLock);\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleNewTopic(ev: NewTopic): void {\r\n        if (this.room.id === ev.roomId) {\r\n            this.createHistoryWindowForTopic(ev.topic);\r\n        }\r\n    }\r\n\r\n    private handleTopicDeleted(ev: TopicDeleted): void {\r\n        if (this.room.id === ev.location.roomId) {\r\n            this.historyWindows.delete(ev.location.topicId);\r\n        }\r\n    }\r\n\r\n    private createHistoryWindowForTopic(topic: Topic): void {\r\n        if (this.historyWindows.has(topic.id)) {\r\n            return;\r\n        }\r\n\r\n        const historyWindow = new TopicHistoryWindow(this.room.id, topic.id, this.tracker);\r\n\r\n        historyWindow.setTraverseLock(this.traverseLock);\r\n\r\n        this.historyWindows.set([topic.id, historyWindow]);\r\n\r\n        // If new topic refers to some message from this room, update other structures\r\n        if (topic.refMessage) {\r\n            const refHistoryWindow = this.historyWindows.get(topic.refMessage.location.topicId);\r\n            refHistoryWindow?._updateMessageReference(topic);\r\n        }\r\n    }\r\n\r\n    private updateTraverseLock(room: Room): void {\r\n        this.traverseLock = room.history.mode === 'Ephemeral';\r\n    }\r\n}","import {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {\r\n    ChatLocation,\r\n    NewMessage,\r\n    FollowedTopic,\r\n    TopicFollowed,\r\n    TopicUnfollowed,\r\n    RoomDeleted,\r\n    RoomLeft,\r\n    TopicDeleted,\r\n    FollowedTopicUpdated, RoomJoined, NewTopic, Session, Room, MessageType,\r\n} from \"../types/src\";\r\nimport {\r\n    IndexedCollection,\r\n    ObservableIndexedObjectCollection\r\n} from \"../IndexedObjectCollection\";\r\nimport {DeferredTask, PromiseRegistry} from \"./AsyncUtils\";\r\nimport {RoomMessagesHistory} from \"./RoomMessagesHistory\";\r\n\r\nexport class MessagesManager {\r\n    private readonly roomHistories = new IndexedCollection<string, RoomMessagesHistory>();\r\n    private readonly followedTopics = new IndexedCollection<string, ObservableIndexedObjectCollection<FollowedTopic>>();\r\n    private readonly followedTopicsPromises = new PromiseRegistry();\r\n    private readonly deferredSession = new DeferredTask();\r\n\r\n    public constructor(private tracker: ChatStateTracker) {\r\n        this.tracker.client.on('Session', ev => this.handleSession(ev));\r\n        this.tracker.client.on('RoomJoined', ev => this.handleRoomJoin(ev));\r\n        this.tracker.client.on('NewTopic', ev => this.handleNewTopic(ev));\r\n        this.tracker.client.on('FollowedTopicUpdated', ev => this.handleFollowedTopicUpdated(ev));\r\n        this.tracker.client.on('TopicFollowed', ev => this.handleTopicFollowed(ev));\r\n        this.tracker.client.on('TopicUnfollowed', ev => this.handleTopicUnfollowed(ev));\r\n        this.tracker.client.on('NewMessage', ev => this.handleNewMessage(ev));\r\n        this.tracker.client.on('RoomDeleted', ev => this.handleRoomDeleted(ev));\r\n        this.tracker.client.on('RoomLeft', ev => this.handleRoomLeft(ev));\r\n        this.tracker.client.on('TopicDeleted', ev => this.handleTopicDeleted(ev));\r\n    }\r\n\r\n    /**\r\n     * Get history manager for given room ID.\r\n     */\r\n    public async getRoomHistory(roomId: string): Promise<RoomMessagesHistory | undefined> {\r\n        await this.deferredSession.promise;\r\n        return this.roomHistories.get(roomId);\r\n    }\r\n\r\n    /**\r\n     * Cache followed topics for all joined rooms in a space and fetch them in bulk if necessary.\r\n     * Then you can get them using getRoomFollowedTopics().\r\n     * @see getRoomFollowedTopics\r\n     */\r\n    public async cacheSpaceFollowedTopics(spaceId: string | null): Promise<void> {\r\n        if (spaceId && ! (await this.tracker.spaces.get()).has(spaceId)) {\r\n            throw new Error(`You are not in space ${spaceId}`);\r\n        }\r\n\r\n        const roomIds = (await this.tracker.rooms.get()).findBy('spaceId', spaceId).items.map(room => room.id);\r\n\r\n        if (! roomIds.length) {\r\n            // We don't need to ping server for followed topics for this space, if user has no joined rooms\r\n            return;\r\n        }\r\n\r\n        const resultPromise = this.tracker.client.send('GetFollowedTopics', {location: {spaceId}});\r\n\r\n        roomIds.forEach(roomId => this.followedTopicsPromises.register(resultPromise, roomId));\r\n\r\n        const result = await resultPromise;\r\n\r\n        if (result.error) {\r\n            throw result.error;\r\n        }\r\n\r\n        this.setFollowedTopicsArray(roomIds, result.data.followedTopics);\r\n    }\r\n\r\n    /**\r\n     * Get followed topics for the given room.\r\n     * @return Undefined if you are not in the room, collection otherwise.\r\n     */\r\n    public async getRoomFollowedTopics(roomId: string): Promise<ObservableIndexedObjectCollection<FollowedTopic> | undefined> {\r\n        if (! (await this.tracker.rooms.get()).has(roomId)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (! this.followedTopics.has(roomId)) {\r\n            if (this.followedTopicsPromises.notExist(roomId)) {\r\n                this.followedTopicsPromises.registerByFunction(async () => {\r\n                    const result = await this.tracker.client.send('GetFollowedTopics', {location: {roomId}});\r\n\r\n                    if (result.error) {\r\n                        throw result.error;\r\n                    }\r\n\r\n                    this.setFollowedTopicsArray([roomId], result.data.followedTopics);\r\n                }, roomId);\r\n            }\r\n\r\n            await this.followedTopicsPromises.get(roomId);\r\n        }\r\n\r\n        return this.followedTopics.get(roomId);\r\n    }\r\n\r\n    /**\r\n     * Batch acknowledge all missed messages from any topics in given room.\r\n     */\r\n    public async ackRoomFollowedTopics(roomId: string): Promise<void> {\r\n        const collection = await this.getRoomFollowedTopics(roomId);\r\n\r\n        if (! collection) {\r\n            return;\r\n        }\r\n\r\n        for (const followedTopic of collection.items) {\r\n            if (followedTopic.missed) {\r\n                await this.tracker.client.send('Ack', {location: followedTopic.location});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate missed messages from any topic in given room.\r\n     * @return Undefined if you are not in room.\r\n     */\r\n    public async calculateRoomMissedMessages(roomId: string): Promise<number | undefined> {\r\n        const collection = await this.getRoomFollowedTopics(roomId);\r\n\r\n        if (collection) {\r\n            return collection.items.reduce(\r\n                (previousValue, currentValue) => previousValue + (currentValue.missed ?? 0),\r\n                0,\r\n            );\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * For internal use. If you want to delete the message, execute a proper command on client object.\r\n     * @internal\r\n     */\r\n    public _deleteByTopicIds(roomId: string, ...topicIds: string[]): void {\r\n        this.followedTopics.get(roomId)?.delete(...topicIds);\r\n    }\r\n\r\n    private createHistoryForNewRoom(room: Room): void {\r\n        this.roomHistories.set([room.id, new RoomMessagesHistory(room, this.tracker)]);\r\n    }\r\n\r\n    private handleNewMessage(ev: NewMessage): void {\r\n        this.updateLocallyFollowedTopicOnNewMessage(ev);\r\n    }\r\n\r\n    private handleFollowedTopicUpdated(ev: FollowedTopicUpdated): void {\r\n        this.followedTopics.get(ev.followedTopic.location.roomId)?.set(ev.followedTopic);\r\n    }\r\n\r\n    private handleTopicFollowed(ev: TopicFollowed): void {\r\n        this.setFollowedTopicsArray([ev.followedTopic.location.roomId], [ev.followedTopic]);\r\n    }\r\n\r\n    private handleTopicUnfollowed(ev: TopicUnfollowed): void {\r\n        this.followedTopics.get(ev.location.roomId)?.delete(ev.location.topicId);\r\n    }\r\n\r\n    private handleRoomDeleted(ev: RoomDeleted): void {\r\n        this.roomHistories.delete(ev.id);\r\n        this.clearRoomFollowedTopicsStructures(ev.id);\r\n    }\r\n\r\n    private handleRoomJoin(ev: RoomJoined): void {\r\n        this.createHistoryForNewRoom(ev.room)\r\n        this.clearRoomFollowedTopicsStructures(ev.room.id);\r\n    }\r\n\r\n    private handleRoomLeft(ev: RoomLeft): void {\r\n        this.roomHistories.delete(ev.id);\r\n        this.clearRoomFollowedTopicsStructures(ev.id);\r\n    }\r\n\r\n    private async handleNewTopic(ev: NewTopic): Promise<void> {\r\n        if (this.followedTopics.has(ev.roomId)) {\r\n            // Check if the new topic is followed by user\r\n            // only if client asked for followed topics list before for this room\r\n            const result = await this.tracker.client.send(\r\n                'GetFollowedTopics',\r\n                {location: {roomId: ev.roomId, topicId: ev.topic.id}},\r\n            );\r\n            const followedTopic = result.data.followedTopics[0];\r\n            if (followedTopic) {\r\n                this.followedTopics.get(ev.roomId).set(followedTopic);\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleTopicDeleted(ev: TopicDeleted): void {\r\n        this.followedTopics.get(ev.location.roomId)?.delete(ev.location.topicId);\r\n    }\r\n\r\n    private handleSession(ev: Session): void {\r\n        this.followedTopics.deleteAll();\r\n        this.followedTopicsPromises.forgetAll();\r\n        this.roomHistories.deleteAll();\r\n        ev.state.rooms.forEach(room => this.createHistoryForNewRoom(room));\r\n        this.deferredSession.resolve();\r\n    }\r\n\r\n    private updateLocallyFollowedTopicOnNewMessage(ev: NewMessage): void {\r\n        const roomFollowedTopics = this.followedTopics.get(ev.message.location.roomId);\r\n        const followedTopic = roomFollowedTopics?.get(ev.message.location.topicId);\r\n\r\n        if (!roomFollowedTopics || !followedTopic || ev.message.type === 'Ephemeral') {\r\n            // Skip if we don't follow this room or targeted topic or the message is ephemeral\r\n            return;\r\n        }\r\n\r\n        const isMe = ev.message.author.user.id === this.tracker.me?.id;\r\n\r\n        let update: Partial<FollowedTopic>;\r\n\r\n        if (isMe) {\r\n            // Reset missed messages count if new message is authored by me\r\n            update = {missed: 0, lastAckMessageId: ev.message.id};\r\n        } else {\r\n            // ...add 1 otherwise\r\n            update = {missed: followedTopic.missed === null ? null : followedTopic.missed + 1};\r\n        }\r\n\r\n        roomFollowedTopics.set({...followedTopic, ...update});\r\n    }\r\n\r\n    private setFollowedTopicsArray(roomIds: string[], followedTopics: FollowedTopic[]): void {\r\n        const roomToTopics: {[roomId: string]: FollowedTopic[]} = {};\r\n\r\n        // Reassign followed topics to limit collection change event emit\r\n        followedTopics.forEach(followedTopic => {\r\n            roomToTopics[followedTopic.location.roomId] ??= [];\r\n            roomToTopics[followedTopic.location.roomId].push(followedTopic);\r\n        });\r\n\r\n        roomIds.forEach(roomId => {\r\n            if (! this.followedTopics.has(roomId)) {\r\n                this.followedTopics.set([roomId, new ObservableIndexedObjectCollection<FollowedTopic>(\r\n                    followedTopic => followedTopic.location.topicId\r\n                )]);\r\n            }\r\n\r\n            if (roomToTopics[roomId]) {\r\n                this.followedTopics.get(roomId).set(...roomToTopics[roomId]);\r\n            }\r\n        });\r\n    }\r\n\r\n    private clearRoomFollowedTopicsStructures(roomId: string): void {\r\n        this.followedTopics.delete(roomId);\r\n        this.followedTopicsPromises.forget(roomId);\r\n    }\r\n}","import {IndexedCollection, ObservableIndexedObjectCollection} from \"../IndexedObjectCollection\";\r\nimport {\r\n    NewMessage,\r\n    NewTopic,\r\n    Room, RoomDeleted,\r\n    RoomJoined, RoomLeft,\r\n    RoomMember, RoomMemberJoined, RoomMemberLeft, RoomMembers,\r\n    RoomMemberUpdated, RoomUpdated, Session, SpaceDeleted, SpaceLeft, SpaceMemberLeft,\r\n    SpaceMemberUpdated,\r\n    Topic,\r\n    TopicDeleted, TopicUpdated,\r\n    UserUpdated,\r\n} from \"../types/src\";\r\nimport {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {DeferredTask, PromiseRegistry} from \"./AsyncUtils\";\r\nimport {MessagesManager} from \"./MessagesManager\";\r\n\r\nexport class RoomsManager {\r\n    public readonly messages: MessagesManager;\r\n\r\n    private readonly list = new ObservableIndexedObjectCollection<Room>('id');\r\n    private readonly topics = new IndexedCollection<string, ObservableIndexedObjectCollection<Topic>>();\r\n    private readonly members = new IndexedCollection<string, ObservableIndexedObjectCollection<RoomMember>>();\r\n    private readonly deferredSession = new DeferredTask();\r\n    private readonly membersPromises = new PromiseRegistry();\r\n    private readonly topicsPromises = new PromiseRegistry();\r\n\r\n    public constructor(private tracker: ChatStateTracker) {\r\n        this.messages = new MessagesManager(tracker);\r\n\r\n        this.tracker.client.on('NewMessage', ev => this.handleNewMessage(ev));\r\n        this.tracker.client.on('NewTopic', ev => this.handleNewTopic(ev));\r\n        this.tracker.client.on('TopicDeleted', ev => this.handleTopicDeleted(ev));\r\n        this.tracker.client.on('RoomJoined', ev => this.handleRoomJoined(ev));\r\n        this.tracker.client.on('RoomLeft', ev => this.handleRoomLeft(ev));\r\n        this.tracker.client.on('RoomUpdated', ev => this.handleRoomUpdated(ev));\r\n        this.tracker.client.on('RoomDeleted', ev => this.handleRoomDeleted(ev));\r\n        this.tracker.client.on('TopicUpdated', ev => this.handleTopicUpdated(ev));\r\n        this.tracker.client.on('RoomMemberJoined', ev => this.handleRoomMemberJoined(ev));\r\n        this.tracker.client.on('RoomMemberLeft', ev => this.handleRoomMemberLeft(ev));\r\n        this.tracker.client.on('RoomMembers', ev => this.handleRoomMembers(ev));\r\n        this.tracker.client.on('RoomMemberUpdated', ev => this.handleRoomMemberUpdated(ev));\r\n        this.tracker.client.on('SpaceMemberLeft', ev => this.handleSpaceMemberLeft(ev));\r\n        this.tracker.client.on('SpaceMemberUpdated', ev => this.handleSpaceMemberUpdated(ev));\r\n        this.tracker.client.on('SpaceDeleted', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('SpaceLeft', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('UserUpdated', ev => this.handleUserUpdated(ev));\r\n        this.tracker.client.on('Session', ev => this.handleSession(ev));\r\n    }\r\n\r\n    /**\r\n     * Get collection of room members.\r\n     */\r\n    public async getMembers(roomId: string): Promise<ObservableIndexedObjectCollection<RoomMember> | undefined> {\r\n        if (this.membersPromises.notExist(roomId)) {\r\n            this.membersPromises.registerByFunction(async () => {\r\n                const result = await this.tracker.client.send('GetRoomMembers', {id: roomId});\r\n                if (result.error) {\r\n                    throw result.error;\r\n                }\r\n                this.handleRoomMembers(result.data);\r\n            }, roomId);\r\n        }\r\n\r\n        await this.membersPromises.get(roomId);\r\n        return this.members.get(roomId);\r\n    }\r\n\r\n    /**\r\n     * Get a room member representing the current user.\r\n     */\r\n    public async getMe(roomId: string): Promise<RoomMember | undefined> {\r\n        const userId = (await this.tracker.getMe()).id;\r\n\r\n        if (! this.list.has(roomId)) {\r\n            // User is not in passed room.\r\n            return undefined;\r\n        }\r\n\r\n        const members = await this.getMembers(roomId);\r\n        return members?.items.find(member => (member.user?.id ?? member.spaceMember.user.id) === userId);\r\n    }\r\n\r\n    /**\r\n     * Get collection of all the rooms you are in.\r\n     */\r\n    public async get(): Promise<ObservableIndexedObjectCollection<Room>> {\r\n        await this.deferredSession.promise;\r\n        return this.list;\r\n    }\r\n\r\n    /**\r\n     * Get a collection of locally cached Topic objects for given room.\r\n     * You can pass topic ids as second argument, to try to fetch them from the server.\r\n     */\r\n    public async getTopics(roomId: string, tryToFetchTopicIds?: string[]): Promise<ObservableIndexedObjectCollection<Topic> | undefined> {\r\n        await this.deferredSession.promise;\r\n\r\n        if (tryToFetchTopicIds?.length) {\r\n            // Topic can be fetched if it isn't already cached and fetch is not already in progress\r\n            const canFetch = (topicId: string) => ! this.topics.get(roomId)?.has(topicId) && ! this.topicsPromises.has(roomId + topicId);\r\n            const idsToFetch = tryToFetchTopicIds.filter(canFetch);\r\n\r\n            if (idsToFetch.length) {\r\n                const promise = this.tracker\r\n                    .client\r\n                    .send('GetTopics', {roomId, topicIds: idsToFetch})\r\n                    .then(result => this.topics.get(result.data.location.roomId)?.set(...result.data.topics));\r\n\r\n                idsToFetch.forEach(topicId => this.topicsPromises.register(promise, roomId + topicId));\r\n            }\r\n\r\n            for (const topicId of tryToFetchTopicIds) {\r\n                await this.topicsPromises.get(roomId + topicId);\r\n            }\r\n        }\r\n\r\n        return this.topics.get(roomId);\r\n    }\r\n\r\n    private deleteRoom(...roomIds: string[]): void {\r\n        this.list.delete(...roomIds);\r\n        this.members.delete(...roomIds);\r\n        this.membersPromises.forget(...roomIds);\r\n\r\n        for (const roomId of roomIds) {\r\n            const topicIds: string[] = this.topics.get(roomId)?.items.map(topic => topic.id) ?? [];\r\n            this.messages._deleteByTopicIds(roomId, ...topicIds);\r\n        }\r\n\r\n        this.topics.delete(...roomIds);\r\n    }\r\n\r\n    private deleteRoomsBySpaceId(spaceId: string): void {\r\n        this.deleteRoom(\r\n            ...this.list.findBy('spaceId', spaceId).items.map(room => room.id)\r\n        );\r\n    }\r\n\r\n    private handleSpaceMemberUpdated(ev: SpaceMemberUpdated): void {\r\n        // Update members of rooms related to this space\r\n        for (const room of this.list.findBy('spaceId', ev.spaceId).items) {\r\n            const roomMembers = this.members.get(room.id);\r\n\r\n            if (! roomMembers || ! roomMembers.has(ev.userId)) {\r\n                // Skip update if member list for this room is not loaded\r\n                // or user is not in room\r\n                continue;\r\n            }\r\n\r\n            const roomMember = roomMembers.get(ev.userId);\r\n            const user = roomMember.spaceMember.user;\r\n\r\n            // Update space member but first fill user object (it's null in event object)\r\n            roomMember.spaceMember = {...ev.member, user};\r\n            roomMembers.set(roomMember);\r\n        }\r\n    }\r\n\r\n    private handleSpaceMemberLeft(ev: SpaceMemberLeft): void {\r\n        this.list\r\n            .findBy('spaceId', ev.spaceId).items\r\n            .forEach(room => this.members.get(room.id)?.delete(ev.userId));\r\n    }\r\n\r\n    private handleRoomMemberUpdated(ev: RoomMemberUpdated): void {\r\n        if (! this.members.has(ev.roomId)) {\r\n            // We do not track member list for this room.\r\n            return;\r\n        }\r\n\r\n        const members = this.members.get(ev.roomId);\r\n        const member = members.get(ev.userId);\r\n        const newMember = ev.member;\r\n        const user = member.spaceMember?.user ?? member.user;\r\n\r\n        // Preserving user object, because it's not included in event\r\n        if (newMember.spaceMember) {\r\n            newMember.spaceMember.user = user;\r\n        } else {\r\n            newMember.user = user;\r\n        }\r\n\r\n        members.set(newMember);\r\n    }\r\n\r\n    private handleSpaceDeleted(ev: SpaceDeleted | SpaceLeft): void {\r\n        this.deleteRoomsBySpaceId(ev.id);\r\n    }\r\n\r\n    private handleTopicDeleted(ev: TopicDeleted): void {\r\n        const collection = this.topics.get(ev.location.roomId);\r\n        collection.delete(ev.location.topicId);\r\n\r\n        const room = this.list.get(ev.location.roomId);\r\n        if (room.defaultTopic?.id === ev.location.topicId) {\r\n            this.list.set({...room, defaultTopic: null});\r\n        }\r\n    }\r\n\r\n    private handleNewTopic(ev: NewTopic): void {\r\n        this.addJoinedRoomTopics(ev.roomId, ev.topic);\r\n    }\r\n\r\n    private addJoinedRoomTopics(roomId: string, ...topics: Topic[]): void {\r\n        if (this.topics.has(roomId)) {\r\n            this.topics.get(roomId).set(...topics);\r\n        } else {\r\n            this.topics.set([roomId, new ObservableIndexedObjectCollection<Topic>('id', topics)]);\r\n        }\r\n    }\r\n\r\n    private handleRoomJoined(ev: RoomJoined): void {\r\n        this.addJoinedRooms(ev.room);\r\n    }\r\n\r\n    private handleRoomUpdated(ev: RoomUpdated): void {\r\n        if (this.list.has(ev.room.id)) {\r\n            this.list.set(ev.room);\r\n        }\r\n    }\r\n\r\n    private handleRoomDeleted(ev: RoomDeleted): void {\r\n        this.deleteRoom(ev.id);\r\n    }\r\n\r\n    private handleTopicUpdated(ev: TopicUpdated): void {\r\n        const room = this.list.get(ev.location.roomId);\r\n\r\n        if (this.topics.get(ev.location.roomId)?.has(ev.topic.id)) {\r\n            this.topics.get(ev.location.roomId).set(ev.topic);\r\n        }\r\n\r\n        if (room.defaultTopic.id === ev.topic.id) {\r\n            room.defaultTopic = ev.topic;\r\n            this.list.set(room);\r\n        }\r\n    }\r\n\r\n    private addJoinedRooms(...rooms: Room[]): void {\r\n        for (const room of rooms) {\r\n            if (room.defaultTopic) {\r\n                this.addJoinedRoomTopics(room.id, room.defaultTopic);\r\n            }\r\n\r\n            if (room.type === 'Pm' && room.recipients) {\r\n                // Treat PM recipients as normal room members.\r\n                // We are registering fake promise in `memberPromises`\r\n                // because GetMembers are not supported for PM rooms.\r\n                this.handleRoomMembers({\r\n                    id: room.id,\r\n                    members: room.recipients.map(user => ({user, spaceMember: null, roles: null})),\r\n                });\r\n                this.membersPromises.register(Promise.resolve(), room.id);\r\n            }\r\n        }\r\n        this.list.set(...rooms);\r\n    }\r\n\r\n    private handleRoomLeft(ev: RoomLeft): void {\r\n        this.deleteRoom(ev.id);\r\n    }\r\n\r\n    private handleRoomMemberJoined(ev: RoomMemberJoined): void {\r\n        if (this.members.has(ev.roomId)) {\r\n            this.members.get(ev.roomId).set(ev.member);\r\n        }\r\n    }\r\n\r\n    private handleRoomMemberLeft(ev: RoomMemberLeft): void {\r\n        if (this.members.has(ev.roomId)) {\r\n            this.members.get(ev.roomId).delete(ev.userId);\r\n        }\r\n    }\r\n\r\n    private handleRoomMembers(ev: RoomMembers): void {\r\n        if (! this.members.has(ev.id)) {\r\n            this.members.set([\r\n                ev.id,\r\n                new ObservableIndexedObjectCollection(\r\n                    member => member.user?.id ?? member.spaceMember.user.id,\r\n                    ev.members,\r\n                )\r\n            ]);\r\n        }\r\n    }\r\n\r\n    private handleSession(ev: Session): void {\r\n        this.list.deleteAll();\r\n        this.topics.deleteAll();\r\n        this.topicsPromises.forgetAll();\r\n        this.members.deleteAll();\r\n        this.membersPromises.forgetAll();\r\n\r\n        this.addJoinedRooms(...ev.state.rooms);\r\n\r\n        this.deferredSession.resolve();\r\n    }\r\n\r\n    private handleUserUpdated(ev: UserUpdated): void {\r\n        // Update room members users\r\n        this.members.items.forEach((members) => {\r\n            const member = members.get(ev.user.id);\r\n\r\n            if (! member) {\r\n                // Skip room; updated user is not here\r\n                return;\r\n            }\r\n\r\n            const newMember: RoomMember = {...member};\r\n\r\n            if (member.user) {\r\n                newMember.user = ev.user;\r\n            } else {\r\n                newMember.spaceMember.user = ev.user;\r\n            }\r\n\r\n            members.set(newMember);\r\n        });\r\n\r\n        // Update recipients users\r\n        const newRooms: Room[] = [];\r\n        this.list.items.forEach(room => {\r\n            if (room.recipients?.some(user => user.id === ev.user.id)) {\r\n                room.recipients = room.recipients.map(user => user.id === ev.user.id ? ev.user : user);\r\n                newRooms.push({...room});\r\n            }\r\n        });\r\n        this.list.set(...newRooms);\r\n    }\r\n\r\n    private handleNewMessage(ev: NewMessage): void {\r\n        const topics = this.topics.get(ev.message.location.roomId);\r\n        const topic = topics?.get(ev.message.location.topicId);\r\n\r\n        if (!topic) {\r\n            return; // No topic found, nothing to update\r\n        }\r\n\r\n        const newTopic = {\r\n            ...topic,\r\n            messageCount: topic.messageCount + 1,\r\n            lastMessage: ev.message,\r\n        };\r\n\r\n        topics.set(newTopic);\r\n        const room = this.list.get(ev.message.location.roomId);\r\n\r\n        if (room.defaultTopic?.id === ev.message.location.topicId) {\r\n            this.list.set({ ...room, defaultTopic: newTopic });\r\n        }\r\n    }\r\n}","import {Role, RoomMember, SpaceMember, User} from \"../types/src\";\r\n\r\nexport function reorderRolesOnPriorityUpdate(allRoles: Role[], oldRole: Role, updatedRole: Role): Role[] {\r\n    // If the priority has changed, adjust the rest of roles\r\n    const increased = (updatedRole.priority - oldRole.priority) > 0;\r\n    const decreased = ! increased;\r\n    const changedRoles: Role[] = [];\r\n\r\n    allRoles.forEach(role => {\r\n        if (role.id === updatedRole.id) {\r\n            // Skip the updated role\r\n            return;\r\n        }\r\n        if (increased && oldRole.priority <= role.priority) {\r\n            role.priority--;\r\n            changedRoles.push(role);\r\n        }\r\n        if (decreased && updatedRole.priority <= role.priority) {\r\n            role.priority++;\r\n            changedRoles.push(role);\r\n        }\r\n    });\r\n\r\n    return changedRoles;\r\n}\r\n\r\nexport function extractUserFromMember(member: RoomMember | SpaceMember): User | null {\r\n    return member.user ?? (member as RoomMember).spaceMember?.user;\r\n}","import {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {IndexedCollection, ObservableIndexedObjectCollection} from \"../IndexedObjectCollection\";\r\nimport {\r\n    NewRole,\r\n    NewRoom,\r\n    Role,\r\n    RoleDeleted,\r\n    RoleUpdated,\r\n    RoomDeleted,\r\n    RoomSummary,\r\n    RoomSummaryUpdated,\r\n    RoomUpdated,\r\n    Session,\r\n    Space,\r\n    SpaceDeleted,\r\n    SpaceJoined,\r\n    SpaceLeft,\r\n    SpaceMember,\r\n    SpaceMemberJoined,\r\n    SpaceMemberLeft,\r\n    SpaceMembers,\r\n    SpaceMemberUpdated,\r\n    SpaceRooms,\r\n    SpaceUpdated,\r\n    UserUpdated\r\n} from \"../types/src\";\r\nimport {DeferredTask, PromiseRegistry} from \"./AsyncUtils\";\r\nimport {reorderRolesOnPriorityUpdate} from \"./functions\";\r\n\r\nexport class SpacesManager {\r\n    private readonly list = new ObservableIndexedObjectCollection<Space>('id');\r\n    private readonly roles = new IndexedCollection<string, ObservableIndexedObjectCollection<Role>>();\r\n    private readonly rooms = new IndexedCollection<string, ObservableIndexedObjectCollection<RoomSummary>>();\r\n    private readonly roomIdToSpaceId = new IndexedCollection<string, string>();\r\n    private readonly members = new IndexedCollection<string, ObservableIndexedObjectCollection<SpaceMember>>();\r\n    private readonly deferredSession = new DeferredTask();\r\n    private readonly roomsPromises = new PromiseRegistry();\r\n    private readonly membersPromises = new PromiseRegistry();\r\n\r\n    public constructor(private tracker: ChatStateTracker) {\r\n        this.tracker.client.on('NewRoom', ev => this.handleNewRoom(ev));\r\n        this.tracker.client.on('RoomDeleted', ev => this.handleRoomDeleted(ev));\r\n        this.tracker.client.on('RoomUpdated', ev => this.handleRoomUpdated(ev));\r\n        this.tracker.client.on('SpaceDeleted', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('SpaceUpdated', ev => this.handleSpaceUpdated(ev));\r\n        this.tracker.client.on('SpaceJoined', ev => this.handleSpaceJoined(ev));\r\n        this.tracker.client.on('SpaceLeft', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('SpaceMemberJoined', ev => this.handleSpaceMemberJoined(ev));\r\n        this.tracker.client.on('SpaceMemberLeft', ev => this.handleSpaceMemberLeft(ev));\r\n        this.tracker.client.on('SpaceMembers', ev => this.handleSpaceMembers(ev));\r\n        this.tracker.client.on('SpaceRooms', ev => this.handleSpaceRooms(ev));\r\n        this.tracker.client.on('RoomSummaryUpdated', ev => this.handleRoomSummaryUpdated(ev));\r\n        this.tracker.client.on('SpaceMemberUpdated', ev => this.handleSpaceMemberUpdated(ev));\r\n        this.tracker.client.on('UserUpdated', ev => this.handleUserUpdated(ev));\r\n        this.tracker.client.on('NewRole', ev => this.handleNewRole(ev));\r\n        this.tracker.client.on('RoleDeleted', ev => this.handleRoleDeleted(ev));\r\n        this.tracker.client.on('RoleUpdated', ev => this.handleRoleUpdated(ev));\r\n        this.tracker.client.on('Session', ev => this.handleSession(ev));\r\n    }\r\n\r\n    /**\r\n     * Get collection of all the spaces you are in.\r\n     */\r\n    public async get(): Promise<ObservableIndexedObjectCollection<Space>> {\r\n        await this.deferredSession.promise;\r\n        return this.list;\r\n    }\r\n\r\n    /**\r\n     * Get collection of space roles.\r\n     */\r\n    public async getRoles(spaceId: string): Promise<ObservableIndexedObjectCollection<Role> | undefined> {\r\n        await this.deferredSession.promise;\r\n        return this.roles.get(spaceId);\r\n    }\r\n\r\n    /**\r\n     * Get collection of the all available rooms inside given space.\r\n     */\r\n    public async getRooms(spaceId: string): Promise<ObservableIndexedObjectCollection<RoomSummary> | undefined> {\r\n        if (this.roomsPromises.notExist(spaceId)) {\r\n            this.roomsPromises.registerByFunction(async () => {\r\n                const result = await this.tracker.client.send('GetSpaceRooms', {id: spaceId});\r\n                if (result.error) {\r\n                    throw result.error;\r\n                }\r\n                this.handleSpaceRooms(result.data);\r\n            }, spaceId);\r\n        }\r\n\r\n        await this.roomsPromises.get(spaceId);\r\n        return this.rooms.get(spaceId);\r\n    }\r\n\r\n    /**\r\n     * Get collection of space members.\r\n     */\r\n    public async getMembers(spaceId: string): Promise<ObservableIndexedObjectCollection<SpaceMember> | undefined> {\r\n        if (this.membersPromises.notExist(spaceId)) {\r\n            this.membersPromises.registerByFunction(async () => {\r\n                const result = await this.tracker.client.send('GetSpaceMembers', {id: spaceId});\r\n                if (result.error) {\r\n                    throw result.error;\r\n                }\r\n                this.handleSpaceMembers(result.data);\r\n            }, spaceId);\r\n        }\r\n\r\n        await this.membersPromises.get(spaceId);\r\n        return this.members.get(spaceId);\r\n    }\r\n\r\n    /**\r\n     * Get a space member representing the current user.\r\n     */\r\n    public async getMe(spaceId: string): Promise<SpaceMember | undefined> {\r\n        const userId = (await this.tracker.getMe()).id;\r\n\r\n        if (! this.list.has(spaceId)) {\r\n            // User is not in passed space.\r\n            return undefined;\r\n        }\r\n\r\n        const members = await this.getMembers(spaceId);\r\n        return members?.items.find(member => member.user.id === userId);\r\n    }\r\n\r\n    private handleNewRole(ev: NewRole): void {\r\n        const collection = this.roles.get(ev.spaceId);\r\n        collection.set(ev.role);\r\n        this.list.get(ev.spaceId).roles = collection.items;\r\n    }\r\n\r\n    private handleNewRoom(ev: NewRoom): void {\r\n        this.rooms.get(ev.spaceId)?.set(ev.summary);\r\n        this.roomIdToSpaceId.set([ev.summary.id, ev.spaceId]);\r\n    }\r\n\r\n    private handleRoomUpdated(ev: RoomUpdated): void {\r\n        if (ev.room.spaceId && this.rooms.has(ev.room.spaceId)) {\r\n            const rooms = this.rooms.get(ev.room.spaceId);\r\n            rooms.set({\r\n                ...rooms.get(ev.room.id),\r\n                name: ev.room.name,\r\n                description: ev.room.description,\r\n            } as RoomSummary);\r\n        }\r\n    }\r\n\r\n    private async handleRoomDeleted(ev: RoomDeleted): Promise<void> {\r\n        const spaceId = this.roomIdToSpaceId.get(ev.id);\r\n        this.roomIdToSpaceId.delete(ev.id);\r\n\r\n        if (! spaceId) {\r\n            return;\r\n        }\r\n\r\n        const space = this.list.get(spaceId);\r\n        let spaceChanged = false;\r\n\r\n        this.rooms.get(spaceId)?.delete(ev.id);\r\n\r\n        if (space.systemRoom === ev.id) {\r\n            space.systemRoom = null;\r\n            spaceChanged = true;\r\n        }\r\n\r\n        if (space.defaultRooms.includes(ev.id)) {\r\n            space.defaultRooms = space.defaultRooms.filter(roomId => roomId !== ev.id);\r\n            spaceChanged = true;\r\n        }\r\n\r\n        if (spaceChanged) {\r\n            this.list.set(space);\r\n        }\r\n    }\r\n\r\n    private handleRoleDeleted(ev: RoleDeleted): void {\r\n        const collection = this.roles.get(ev.spaceId);\r\n        collection.delete(ev.id);\r\n        this.list.get(ev.spaceId).roles = collection.items;\r\n    }\r\n\r\n    private handleSpaceUpdated(ev: SpaceUpdated): void {\r\n        this.list.set(ev.space);\r\n    }\r\n\r\n    private handleSpaceDeleted(ev: SpaceDeleted | SpaceLeft): void {\r\n        const roomIds = this.rooms.get(ev.id)?.items.map(item => item.id) ?? [];\r\n        this.roomIdToSpaceId.delete(...roomIds);\r\n\r\n        this.roles.delete(ev.id);\r\n        this.members.delete(ev.id);\r\n        this.membersPromises.forget(ev.id);\r\n        this.rooms.delete(ev.id);\r\n        this.roomsPromises.forget(ev.id);\r\n        this.list.delete(ev.id);\r\n    }\r\n\r\n    private handleSpaceJoined(ev: SpaceJoined): void {\r\n        this.addJoinedSpaces(ev.space);\r\n    }\r\n\r\n    private addJoinedSpaces(...spaces: Space[]): void {\r\n        this.roles.set(...(spaces.map(space => [\r\n            space.id,\r\n            new ObservableIndexedObjectCollection<Role>('id', space.roles)\r\n        ]) as [string, ObservableIndexedObjectCollection<Role>][]));\r\n        this.list.set(...spaces);\r\n    }\r\n\r\n    private handleSpaceMemberJoined(ev: SpaceMemberJoined): void {\r\n        if (this.members.has(ev.spaceId)) {\r\n            this.members.get(ev.spaceId).set(ev.member);\r\n        }\r\n    }\r\n\r\n    private handleSpaceMemberLeft(ev: SpaceMemberLeft): void {\r\n        if (this.members.has(ev.spaceId)) {\r\n            this.members.get(ev.spaceId).delete(ev.userId);\r\n        }\r\n    }\r\n\r\n    private handleSpaceMembers(ev: SpaceMembers): void {\r\n        if (! this.members.has(ev.id)) {\r\n            this.members.set([\r\n                ev.id,\r\n                new ObservableIndexedObjectCollection(member => member?.user.id, ev.members)\r\n            ]);\r\n        }\r\n    }\r\n\r\n    private handleSpaceRooms(ev: SpaceRooms): void {\r\n        if (!this.rooms.has(ev.id)) {\r\n            this.rooms.set([ev.id, new ObservableIndexedObjectCollection('id', ev.summaries)]);\r\n            ev.summaries.forEach(summary => this.roomIdToSpaceId.set([summary.id, ev.id]));\r\n        }\r\n    }\r\n\r\n    private async handleRoomSummaryUpdated(ev: RoomSummaryUpdated): Promise<void> {\r\n        const spaceId = this.roomIdToSpaceId.get(ev.summary.id);\r\n        const summariesPromise = this.roomsPromises.get(spaceId);\r\n\r\n        /**\r\n         * Update summary only if the list was already loaded.\r\n         * RoomSummaryUpdated event has a partial summary, so we need to update the existing summary by merging it.\r\n         */\r\n        if (spaceId && summariesPromise) {\r\n            await summariesPromise;\r\n\r\n            const summaries = this.rooms.get(spaceId);\r\n            const oldSummary = summaries.get(ev.summary.id);\r\n            let newSummary: RoomSummary;\r\n\r\n            if (oldSummary) {\r\n                newSummary = {...oldSummary, ...ev.summary};\r\n            } else {\r\n                newSummary = ev.summary;\r\n            }\r\n\r\n            summaries.set(newSummary);\r\n        }\r\n    }\r\n\r\n    private handleSpaceMemberUpdated(ev: SpaceMemberUpdated): void {\r\n        if (this.members.has(ev.spaceId)) {\r\n            const members = this.members.get(ev.spaceId);\r\n            const member = members.get(ev.userId);\r\n            members.set({...ev.member, user: member.user});\r\n        }\r\n    }\r\n\r\n    private handleRoleUpdated(ev: RoleUpdated): void {\r\n        const roles = this.roles.get(ev.spaceId);\r\n        const oldRole = roles.get(ev.role.id);\r\n        const newRole = ev.role;\r\n        const rolesToUpdate = [newRole];\r\n\r\n        if (oldRole.priority !== newRole.priority) {\r\n            rolesToUpdate.push(\r\n                ...reorderRolesOnPriorityUpdate(roles.items, oldRole, newRole)\r\n            );\r\n        }\r\n\r\n        this.roles.get(ev.spaceId).set(...rolesToUpdate);\r\n    }\r\n\r\n    private handleSession(ev: Session): void {\r\n        this.list.deleteAll();\r\n        this.roles.deleteAll();\r\n        this.rooms.deleteAll();\r\n        this.roomsPromises.forgetAll();\r\n        this.members.deleteAll();\r\n        this.membersPromises.forgetAll();\r\n        this.roomIdToSpaceId.deleteAll();\r\n\r\n        this.addJoinedSpaces(...ev.state.spaces);\r\n\r\n        this.deferredSession.resolve();\r\n    }\r\n\r\n    private handleUserUpdated(ev: UserUpdated): void {\r\n        this.members.items.forEach((members) => {\r\n            const member = members.get(ev.user.id);\r\n\r\n            if (! member) {\r\n                // Skip space; updated user is not here\r\n                return;\r\n            }\r\n\r\n            members.set({...member, user: ev.user});\r\n        });\r\n    }\r\n}","export enum Layer {\r\n    Global,\r\n    Space,\r\n    Room,\r\n    Topic,\r\n}\r\n\r\nexport class PermissionDefinition {\r\n    value: number;\r\n    maxLayer: Layer;\r\n}\r\n\r\nexport class Permissions {\r\n    public static readonly list = {\r\n        Root: {value: 1 << 0, maxLayer: Layer.Room},\r\n        CreateSpaces: {value: 1 << 1, maxLayer: Layer.Global},\r\n        ManageSpace: {value: 1 << 2, maxLayer: Layer.Space},\r\n        ManageSpaceRoles: {value: 1 << 3, maxLayer: Layer.Space},\r\n        ManageRoom: {value: 1 << 4, maxLayer: Layer.Room},\r\n        CreateTopics: {value: 1 << 5, maxLayer: Layer.Room},\r\n        ManageTopic: {value: 1 << 6, maxLayer: Layer.Topic},\r\n        ManageSpaceMembers: {value: 1 << 7, maxLayer: Layer.Space},\r\n        ManageRoomMembers: {value: 1 << 8, maxLayer: Layer.Room},\r\n        CreateMessages: {value: 1 << 9, maxLayer: Layer.Topic},\r\n        ManagePermissions: {value: 1 << 10, maxLayer: Layer.Topic},\r\n        CreateSpaceRooms: {value: 1 << 11, maxLayer: Layer.Space},\r\n        ManageSpaceRooms: {value: 1 << 12, maxLayer: Layer.Space},\r\n        CreateEmoticons: {value: 1 << 13, maxLayer: Layer.Space},\r\n        ManageEmoticon: {value: 1 << 14, maxLayer: Layer.Space},\r\n        ManageBan: {value: 1 << 15, maxLayer: Layer.Room},\r\n        Kick: {value: 1 << 16, maxLayer: Layer.Room},\r\n        ChangeOwnNick: {value: 1 << 17, maxLayer: Layer.Space},\r\n    };\r\n\r\n    public static getNames(): (keyof typeof this.list)[] {\r\n        return Object.keys(this.list) as any;\r\n    }\r\n\r\n    public static getByName(name: keyof typeof this.list): PermissionDefinition | undefined {\r\n        return this.list[name];\r\n    }\r\n\r\n    public static canBeDefinedOnLayer(permissionName: keyof typeof this.list, layer: Layer): boolean {\r\n        const def = this.getByName(permissionName);\r\n\r\n        if (! def) {\r\n            throw new Error(`Invalid permission name: ${permissionName}`);\r\n        }\r\n\r\n        return layer <= this.getByName(permissionName).maxLayer;\r\n    }\r\n}","import {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {\r\n    ChatLocation,\r\n    PermissionOverwrites, PermissionOverwritesTarget,\r\n    PermissionOverwritesUpdated,\r\n    PermissionOverwritesValue,\r\n    RoleDeleted,\r\n    RoomDeleted,\r\n    RoomLeft, RoomMember, RoomMemberUpdated, Session,\r\n    SpaceDeleted,\r\n    SpaceLeft, SpaceMember,\r\n    SpaceMemberUpdated,\r\n    TopicDeleted,\r\n} from \"../types/src\";\r\nimport {EventHandler, EventTarget} from \"../EventTarget\";\r\nimport {IndexedCollection} from \"../IndexedObjectCollection\";\r\nimport {Permissions} from \"../Permissions\";\r\nimport {PromiseRegistry} from \"./AsyncUtils\";\r\n\r\nconst getOvId = (\r\n    location: ChatLocation,\r\n    target?: PermissionOverwritesTarget,\r\n) => [location.spaceId, location.roomId, location.topicId, target?.type, target?.userId, target?.roleId].filter(Boolean).join('/');\r\n\r\nconst getOvIdByObject\r\n    = (overwrites: PermissionOverwrites | PermissionOverwritesUpdated): string => getOvId(overwrites.location, overwrites.target);\r\n\r\ninterface CheckPermissionsResult {\r\n    /**\r\n     * @deprecated Use `hasAll` instead.\r\n     */\r\n    ok: boolean;\r\n    hasAll: boolean;\r\n    hasAny: boolean;\r\n    missing: string[];\r\n}\r\n\r\nexport class PermissionsManager extends EventTarget {\r\n    private readonly overwrites = new IndexedCollection<string, PermissionOverwrites>();\r\n    private readonly overwritesPromises = new PromiseRegistry();\r\n\r\n    public constructor(private tracker: ChatStateTracker) {\r\n        super();\r\n        this.tracker.client.on('PermissionOverwrites', ev => this.handlePermissionOverwrites(ev));\r\n        this.tracker.client.on('PermissionOverwritesUpdated', ev => this.handlePermissionOverwrites(ev));\r\n        this.tracker.client.on('SpaceDeleted', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('SpaceLeft', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('RoomDeleted', ev => this.handleRoomDeleted(ev));\r\n        this.tracker.client.on('RoomLeft', ev => this.handleRoomDeleted(ev));\r\n        this.tracker.client.on('TopicDeleted', ev => this.handleTopicDeleted(ev));\r\n        this.tracker.client.on('RoleDeleted', ev => this.handleRoleDeleted(ev));\r\n        this.tracker.client.on('SpaceMemberUpdated', ev => this.handleSpaceMemberUpdated(ev));\r\n        this.tracker.client.on('RoomMemberUpdated', ev => this.handleRoomMemberUpdated(ev));\r\n        this.tracker.client.on('Session', ev => this.handleSession(ev));\r\n    }\r\n\r\n    public async getOverwrites(\r\n        location: ChatLocation,\r\n        target: PermissionOverwritesTarget,\r\n    ): Promise<PermissionOverwrites | undefined> {\r\n        this.validateLocation(location);\r\n\r\n        const id = getOvId(location, target);\r\n\r\n        if (this.overwritesPromises.notExist(id)) {\r\n            this.overwritesPromises.registerByFunction(async () => {\r\n                const result = await this.tracker.client.send(\r\n                    'GetPermissionOverwrites',\r\n                    {location, target},\r\n                );\r\n                if (result.error) {\r\n                    throw result.error;\r\n                }\r\n                this.handlePermissionOverwrites(result.data);\r\n            }, id);\r\n        }\r\n\r\n        await this.overwritesPromises.get(id);\r\n        return this.overwrites.get(id);\r\n    }\r\n\r\n    public on(eventName: 'change', handler: EventHandler<any>): this {\r\n        return super.on(eventName, handler);\r\n    }\r\n\r\n    public async check(\r\n        permissionNames: (keyof typeof Permissions.list)[],\r\n        location: ChatLocation,\r\n    ): Promise<CheckPermissionsResult> {\r\n        if (! permissionNames.length) {\r\n            throw new Error('Permission names array cannot be empty');\r\n        }\r\n\r\n        const ownedPermissions = await this.calculatePermissions(location);\r\n        const missing: string[] = [];\r\n\r\n        permissionNames.forEach(name => {\r\n            if (~ ownedPermissions & Permissions.getByName(name).value) {\r\n                missing.push(name as string);\r\n            }\r\n        });\r\n\r\n        return {\r\n            ok: missing.length === 0,\r\n            hasAll: missing.length === 0,\r\n            hasAny: missing.length < permissionNames.length,\r\n            missing,\r\n        };\r\n    }\r\n\r\n    public async calculatePermissions(location: ChatLocation): Promise<number> {\r\n        this.validateLocation(location);\r\n\r\n        const userId = (await this.tracker.getMe()).id;\r\n        const [spaceMember, roomMember] = await this.fetchMembersOrFail(location);\r\n        const userRoles: string[] = [...(spaceMember?.roles ?? []), ...(roomMember?.roles ?? [])];\r\n        const promises: Promise<PermissionOverwritesValue>[] = [\r\n            // Global user overwrites\r\n            this.getOverwrites({}, { type: 'User', userId }).then(v => v.overwrites),\r\n        ];\r\n\r\n        if (location.spaceId && (await this.tracker.spaces.get())?.has(location.spaceId)) {\r\n            const filterLocation: ChatLocation = {spaceId: location.spaceId};\r\n            promises.push(this.collectRoleOverwrites(filterLocation, userRoles));\r\n            promises.push(this.getOverwrites(filterLocation, { type: 'User', userId }).then(v => v.overwrites));\r\n        }\r\n\r\n        if (location.roomId && (await this.tracker.rooms.get())?.has(location.roomId)) {\r\n            const filterLocation: ChatLocation = {spaceId: location.spaceId, roomId: location.roomId};\r\n            if (userRoles.length) {\r\n                promises.push(this.collectRoleOverwrites(filterLocation, userRoles));\r\n            }\r\n            promises.push(this.getOverwrites(filterLocation, { type: 'User', userId }).then(v => v.overwrites));\r\n        }\r\n\r\n        if (location.topicId && (await this.tracker.rooms.getTopics(location.roomId))?.has(location.topicId)) {\r\n            if (userRoles.length) {\r\n                promises.push(this.collectRoleOverwrites(location, userRoles));\r\n            }\r\n            promises.push(this.getOverwrites(location, { type: 'User', userId }).then(v => v.overwrites));\r\n        }\r\n\r\n        return this.resolveOverwritesHierarchy(await Promise.all(promises));\r\n    }\r\n\r\n    private handlePermissionOverwrites(ev: PermissionOverwritesUpdated | PermissionOverwrites): void {\r\n        this.overwrites.set([getOvIdByObject(ev), ev]);\r\n        this.emit('change');\r\n    }\r\n\r\n    private handleSpaceDeleted(ev: SpaceDeleted | SpaceLeft): void {\r\n        const ids = this.deleteOverwritesByIdPrefix(getOvId({spaceId: ev.id}));\r\n        this.overwritesPromises.forget(...ids);\r\n    }\r\n\r\n    private async handleRoomDeleted(ev: RoomDeleted | RoomLeft): Promise<void> {\r\n        const room = (await this.tracker.rooms.get()).get(ev.id);\r\n        if (room) {\r\n            const ids = this.deleteOverwritesByIdPrefix(getOvId({spaceId: room.spaceId, roomId: room.id}));\r\n            this.overwritesPromises.forget(...ids);\r\n        }\r\n    }\r\n\r\n    private handleTopicDeleted(ev: TopicDeleted): void {\r\n        const ids = this.deleteOverwritesByIdPrefix(getOvId(ev.location));\r\n        this.overwritesPromises.forget(...ids);\r\n    }\r\n\r\n    private handleRoleDeleted(ev: RoleDeleted): void {\r\n        const ids = this.deleteOverwritesByIdPrefix(getOvId({spaceId: ev.spaceId}, { type: 'Role', roleId: ev.id }));\r\n        this.overwritesPromises.forget(...ids);\r\n    }\r\n\r\n    private handleSpaceMemberUpdated(ev: SpaceMemberUpdated): void {\r\n        if (ev.userId === this.tracker.me?.id) {\r\n            // User roles in space could potentially have changed\r\n            this.emit('change');\r\n        }\r\n    }\r\n\r\n    private handleRoomMemberUpdated(ev: RoomMemberUpdated): void {\r\n        if (ev.userId === this.tracker.me?.id) {\r\n            // User roles in room could potentially have changed\r\n            this.emit('change');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return Matched and deleted ids\r\n     */\r\n    private deleteOverwritesByIdPrefix(prefix: string): string[] {\r\n        const ids: string[] = [];\r\n        this.overwrites.items.forEach((overwrites) => {\r\n            const id = getOvIdByObject(overwrites);\r\n            if (id.startsWith(prefix)) {\r\n                ids.push(id);\r\n                this.overwrites.delete(id);\r\n            }\r\n        });\r\n        return ids;\r\n    }\r\n\r\n    private async collectRoleOverwrites(\r\n        location: ChatLocation,\r\n        userRoles: string[],\r\n    ): Promise<PermissionOverwritesValue> {\r\n        const roleOverwrites = await Promise.all(userRoles.map(\r\n            roleId => this.getOverwrites(location, { type: 'Role', roleId }),\r\n        ));\r\n\r\n        return this.resolveOverwritesFromRolesByOrder(location.spaceId, roleOverwrites);\r\n    }\r\n\r\n    private async resolveOverwritesFromRolesByOrder(\r\n        spaceId: string,\r\n        overwrites: PermissionOverwrites[],\r\n    ): Promise<PermissionOverwritesValue> {\r\n        let allows = 0, denies = 0;\r\n        const roles = await this.tracker.spaces.getRoles(spaceId);\r\n        const sortedOverwrites = overwrites.sort(\r\n            (a, b) =>\r\n                roles.get(a.target.roleId).priority - roles.get(b.target.roleId).priority\r\n        );\r\n\r\n        // Max length of bit word\r\n        const permissionsLength = overwrites.reduce(\r\n            (previousValue: number, currentValue: PermissionOverwrites) =>\r\n                Math.max(\r\n                    previousValue,\r\n                    currentValue.overwrites.allow?.toString(2).length ?? 0,\r\n                    currentValue.overwrites.deny?.toString(2).length ?? 0,\r\n                ),\r\n            0,\r\n        );\r\n\r\n        sortedOverwrites.forEach(overwriteEvent => {\r\n            const overwrites = overwriteEvent.overwrites;\r\n            const revDecDenies = overwrites.deny?.toString(2).split('').reverse().join('') ?? '';\r\n            const revDecAllows = overwrites.allow?.toString(2).split('').reverse().join('') ?? '';\r\n\r\n            for (let i = 0; i < permissionsLength; i++) {\r\n                const deny = parseInt(revDecDenies[i] ?? '0');\r\n                const allow = parseInt(revDecAllows[i] ?? '0');\r\n\r\n                if (deny) {\r\n                    denies |= 1 << i;\r\n                }\r\n\r\n                if (allow) {\r\n                    allows |= 1 << i;\r\n                }\r\n            }\r\n        });\r\n\r\n        return {allow: allows, deny: denies};\r\n    }\r\n\r\n    private resolveOverwritesHierarchy(permissionOverwritesValues: PermissionOverwritesValue[]): number {\r\n        let result = 0;\r\n\r\n        for (const value of permissionOverwritesValues) {\r\n            if (value.allow & Permissions.getByName('Root').value) {\r\n                return this.getRootAccessValue();\r\n            }\r\n\r\n            result = (result & ~value.deny) | value.allow;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private getRootAccessValue(): number {\r\n        let result = 0;\r\n\r\n        for (const name of Permissions.getNames()) {\r\n            result |= Permissions.getByName(name).value;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private async fetchMembersOrFail(location: ChatLocation): Promise<[SpaceMember | null, RoomMember | null]> {\r\n        const results = await Promise.all([\r\n            location.spaceId ? this.tracker.spaces.getMe(location.spaceId) : null,\r\n            location.roomId ? this.tracker.rooms.getMe(location.roomId) : null,\r\n        ]);\r\n\r\n        const spaceFail = location.spaceId && ! results[0];\r\n        const roomFail = location.roomId && ! results[1];\r\n\r\n        if (spaceFail || roomFail) {\r\n            const layer = spaceFail ? `space (${location.spaceId})` : `room (${location.roomId})`;\r\n            throw new Error(`Attempting to calculate permissions for a ${layer} that the user does not belong to`);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private validateLocation(location: ChatLocation): void {\r\n        if (location.topicId && ! location.roomId) {\r\n            throw new Error('Corrupted arguments hierarchy');\r\n        }\r\n    }\r\n\r\n    private handleSession(ev: Session): void {\r\n        this.overwrites.deleteAll();\r\n        this.overwritesPromises.forgetAll();\r\n    }\r\n}","import {ChatStateTracker} from \"./ChatStateTracker\";\r\nimport {\r\n    IndexedCollection,\r\n    ObservableIndexedObjectCollection\r\n} from \"../IndexedObjectCollection\";\r\nimport {Emoticon, EmoticonDeleted, Emoticons, NewEmoticon, SpaceDeleted} from \"../types/src\";\r\nimport {PromiseRegistry} from \"./AsyncUtils\";\r\n\r\nconst GLOBAL_KEY = 'global';\r\n\r\nexport class EmoticonsManager {\r\n    private list: IndexedCollection<string, ObservableIndexedObjectCollection<Emoticon>> = new IndexedCollection();\r\n    private emoticonsPromises = new PromiseRegistry();\r\n    \r\n    public constructor(private tracker: ChatStateTracker) {\r\n        this.tracker.client.on('Emoticons', ev => this.handleEmoticons(ev));\r\n        this.tracker.client.on('NewEmoticon', ev => this.handleNewEmoticon(ev));\r\n        this.tracker.client.on('EmoticonDeleted', ev => this.handleEmoticonDeleted(ev));\r\n        this.tracker.client.on('SpaceDeleted', ev => this.handleSpaceDeleted(ev));\r\n        this.tracker.client.on('Session', () => this.handleSession());\r\n    }\r\n\r\n    public async get(spaceId?: string): Promise<ObservableIndexedObjectCollection<Emoticon>> {\r\n        const key = spaceId ?? GLOBAL_KEY;\r\n\r\n        if (this.emoticonsPromises.notExist(key)) {\r\n            this.emoticonsPromises.registerByFunction(async () => {\r\n                const result = await this.tracker.client.send('GetEmoticons', {spaceId});\r\n                if (result.error) {\r\n                    throw result.error;\r\n                }\r\n                this.handleEmoticons(result.data);\r\n            }, key);\r\n        }\r\n\r\n        await this.emoticonsPromises.get(key);\r\n        return this.list.get(key);\r\n    }\r\n\r\n    private handleEmoticons(event: Emoticons): void {\r\n        const spaceId = event.location.spaceId ?? GLOBAL_KEY;\r\n\r\n        if (!this.list.has(spaceId)) {\r\n            this.list.set([spaceId, new ObservableIndexedObjectCollection<Emoticon>('id')]);\r\n        }\r\n\r\n        const collection = this.list.get(spaceId);\r\n        collection.set(...event.emoticons);\r\n    }\r\n\r\n    private handleNewEmoticon(ev: NewEmoticon): void {\r\n        const collection = this.list.get(ev.emoticon.spaceId ?? GLOBAL_KEY);\r\n        collection?.set(ev.emoticon);\r\n    }\r\n\r\n    private handleEmoticonDeleted(ev: EmoticonDeleted): void {\r\n        const collection = this.list.get(ev.spaceId ?? GLOBAL_KEY);\r\n        collection?.delete(ev.emoticonId);\r\n    }\r\n\r\n    private handleSpaceDeleted(event: SpaceDeleted): void {\r\n        this.list.delete(event.id);\r\n    }\r\n\r\n    private handleSession(): void {\r\n        this.list.deleteAll();\r\n        this.emoticonsPromises.forgetAll();\r\n    }\r\n}","import {ChatStateTracker} from \"./ChatStateTracker\";\nimport {ObservableIndexedObjectCollection} from \"../IndexedObjectCollection\";\nimport {RoomMember, Session, SpaceMember, User} from \"../types/src\";\nimport {extractUserFromMember} from \"./functions\";\nimport {EventTarget} from \"../EventTarget\";\n\nexport class UsersManager {\n    public readonly onlineStatus = new EventTarget();\n\n    private readonly users: ObservableIndexedObjectCollection<User> = new ObservableIndexedObjectCollection('id');\n\n    public constructor(private tracker: ChatStateTracker) {\n        // RoomMemberUpdated & SpaceMemberUpdated events are not contains user object\n        tracker.client.on('UserUpdated', event => this.handleUsers([event.user]));\n        tracker.client.on('RoomMemberJoined', event => this.handleMembers([event.member]));\n        tracker.client.on('SpaceMemberJoined', event => this.handleMembers([event.member]));\n        tracker.client.on('SpaceMembers', event => this.handleMembers(event.members));\n        tracker.client.on('RoomMembers', event => this.handleMembers(event.members));\n        tracker.client.on('Messages', event => this.handleUsers(event.messages.map(message => message.author.user)));\n        tracker.client.on('NewMessage', event => this.handleUsers([event.message.author.user]));\n        tracker.client.on('Session', event => this.handleSession(event));\n    }\n\n    /**\n     * Get all available (cached) user objects at once.\n     */\n    public async getAvailable(): Promise<ObservableIndexedObjectCollection<User>> {\n        return this.users;\n    }\n\n    private handleMembers(members: (RoomMember | SpaceMember)[]): void {\n        this.handleUsers(members.map(extractUserFromMember));\n    }\n\n    private handleSession(session: Session): void {\n        this.users.deleteAll();\n        this.handleUsers([session.user]);\n    }\n\n    private handleUsers(users: User[]): void {\n        users.forEach(newUser => {\n            const oldUser = this.users.get(newUser.id);\n            if (oldUser && oldUser.online !== newUser.online) {\n                this.onlineStatus.emit('change', newUser);\n            }\n        });\n\n        this.users.set(...users);\n    }\n}","import {ObservableIndexedObjectCollection} from \"../IndexedObjectCollection\";\nimport {\n    NewRelationship,\n    RelationshipDeleted,\n    Relationships,\n    UserRelationship,\n    UserRelationshipType\n} from \"../types/src\";\nimport {PromiseRegistry} from \"./AsyncUtils\";\nimport {ChatStateTracker} from \"./ChatStateTracker\";\n\nconst getId = (refUserId: string, type: UserRelationshipType): string => `${refUserId}-${type}`;\nconst getIdFromRelationship = (relationship: UserRelationship): string => getId(relationship.refUser.id, relationship.type);\n\nexport class RelationshipsManager {\n    private relationships: ObservableIndexedObjectCollection<UserRelationship> = new ObservableIndexedObjectCollection<UserRelationship>(getIdFromRelationship);\n    private promises = new PromiseRegistry();\n\n    public constructor(private tracker: ChatStateTracker) {\n        this.tracker.client.on('Relationships', ev => this.handleRelationships(ev));\n        this.tracker.client.on('NewRelationship', ev => this.handleNewRelationship(ev));\n        this.tracker.client.on('RelationshipDeleted', ev => this.handleRelationshipDeleted(ev));\n        this.tracker.client.on('Session', () => this.handleSession());\n    }\n\n    public async get(): Promise<ObservableIndexedObjectCollection<UserRelationship>> {\n        if (this.promises.notExist('all')) {\n            this.promises.registerByFunction(async () => {\n                const result = await this.tracker.client.send('GetRelationships', {});\n                if (result.error) {\n                    throw result.error;\n                }\n            }, 'all');\n        }\n\n        await this.promises.get('all');\n        return this.relationships;\n    }\n\n    public async exists(refUserId: string, type: UserRelationshipType): Promise<boolean> {\n        await this.get();\n        return this.relationships.has(getId(refUserId, type));\n    }\n\n    private handleRelationships(ev: Relationships): void {\n        this.relationships.deleteAll();\n        ev.relationships.forEach(relationship => {\n            this.relationships.set(relationship);\n        });\n    }\n\n    private handleNewRelationship(ev: NewRelationship): void {\n        if (this.promises.has('all')) {\n            this.relationships.set(ev.relationship);\n        }\n    }\n\n    private handleRelationshipDeleted(ev: RelationshipDeleted): void {\n        if (this.promises.has('all')) {\n            this.relationships.delete(getIdFromRelationship(ev.relationship));\n        }\n    }\n\n    private handleSession(): void {\n        this.promises.forgetAll();\n        this.relationships.deleteAll();\n    }\n}","import {WebSocketChatClient} from \"../WebSocketChatClient\";\r\nimport {Session, User} from \"../types/src\";\r\nimport {RoomsManager} from \"./RoomsManager\";\r\nimport {SpacesManager} from \"./SpacesManager\";\r\nimport {PermissionsManager} from \"./PermissionsManager\";\r\nimport {DeferredTask} from \"./AsyncUtils\";\r\nimport {EmoticonsManager} from \"./EmoticonsManager\";\r\nimport {UsersManager} from \"./UsersManager\";\r\nimport {RelationshipsManager} from \"./RelationshipsManager\";\r\n\r\nexport class ChatStateTracker {\r\n    /**\r\n     * State of your permissions.\r\n     */\r\n    public readonly permissions = new PermissionsManager(this);\r\n\r\n    /**\r\n     * State of the rooms you are in.\r\n     */\r\n    public readonly rooms: RoomsManager = new RoomsManager(this);\r\n\r\n    /**\r\n     * State of the spaces you are in.\r\n     */\r\n    public readonly spaces = new SpacesManager(this);\r\n\r\n    /**\r\n     * State of the emoticons (global and space-related).\r\n     */\r\n    public readonly emoticons = new EmoticonsManager(this);\r\n\r\n    /**\r\n     * Users related state.\r\n     */\r\n    public readonly users = new UsersManager(this);\r\n\r\n    /**\r\n     * State of relationships with other users.\r\n     */\r\n    public readonly relationships = new RelationshipsManager(this);\r\n\r\n    private _me: User = null;\r\n    private readonly deferredSession = new DeferredTask();\r\n\r\n    public constructor(public readonly client: WebSocketChatClient) {\r\n        this.client.on('Session', ev => this.handleSession(ev));\r\n    }\r\n\r\n    public get me(): User | null {\r\n        return this._me;\r\n    }\r\n\r\n    public async getMe(): Promise<User> {\r\n        await this.deferredSession.promise;\r\n        return this._me;\r\n    }\r\n\r\n    private handleSession(ev: Session): void {\r\n        this._me = ev.user;\r\n        this.deferredSession.resolve();\r\n    }\r\n}","import {ObservableInterface} from \"./EventTarget\";\r\nimport {AbstractChatClient, CommandResult, CommandsMap} from \"./AbstractChatClient\";\r\nimport {ChatStateTracker} from \"./state-tracker/ChatStateTracker\";\r\nimport {Envelope} from \"./types/src\";\r\n\r\nexport interface WebSocketClientOptions {\r\n    url: string;\r\n    token: string;\r\n    connectingTimeoutMs?: number;\r\n    awaitQueueSendDelayMs?: number;\r\n    stateTracking?: boolean;\r\n    queryParams?: Record<string, string>;\r\n}\r\n\r\nenum WebSocketChatClientEvent {\r\n    connect = 'connect',\r\n    disconnect = 'disconnect',\r\n    message = 'message',\r\n    error = 'error',\r\n}\r\n\r\nexport class WebSocketChatClient extends AbstractChatClient implements ObservableInterface {\r\n    public readonly Event = WebSocketChatClientEvent;\r\n    public readonly state?: ChatStateTracker;\r\n\r\n    protected ws: WebSocket|null = null;\r\n    protected sendQueue: Envelope[] = [];\r\n    protected connectingTimeoutId: any;\r\n    protected authenticated: boolean;\r\n    protected authenticatedResolvers: [() => void, (error: Error) => void];\r\n\r\n    public constructor(private readonly options: WebSocketClientOptions) {\r\n        super();\r\n        if (this.options.stateTracking ?? true) {\r\n            this.state = new ChatStateTracker(this);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        const params = new URLSearchParams(this.options.queryParams ?? {});\r\n        params.set('token', this.options.token);\r\n\r\n        this.ws = new WebSocket(`${this.options.url}?${params}`);\r\n        this.ws.onclose = ev => this.onClose(ev);\r\n        this.ws.onmessage = ev => this.onMessage(ev);\r\n        this.connectingTimeoutId = setTimeout(\r\n            () => this.triggerConnectionTimeout(),\r\n            this.options.connectingTimeoutMs ?? 10000\r\n        );\r\n        this.authenticated = false;\r\n\r\n        return new Promise((...args) => this.authenticatedResolvers = args);\r\n    }\r\n\r\n    public disconnect(): void {\r\n        this.sendQueue = [];\r\n        this.ws?.close();\r\n        this.ws = null;\r\n    }\r\n\r\n    public async send<CommandType extends keyof CommandsMap>(commandType: CommandType, commandData: CommandsMap[CommandType][0]):\r\n       Promise<CommandResult<CommandsMap[CommandType][1]>> {\r\n        const envelope = this.createEnvelope<CommandsMap[CommandType][0]>(commandType, commandData);\r\n        const promise = this.createPromiseFromCommandEnvelope<CommandType>(envelope);\r\n\r\n        if (this.isPendingReadyWsState()) {\r\n            this.sendQueue.push(envelope);\r\n            return promise;\r\n        }\r\n\r\n        this.sendEnvelope(envelope);\r\n        return promise;\r\n    }\r\n\r\n    private sendEnvelope(envelope: Envelope): void {\r\n        if (this.isReadyToSendWsState()) {\r\n            this.ws.send(JSON.stringify(envelope));\r\n            return;\r\n        }\r\n\r\n        this.handleEnvelopeSendError(\r\n            envelope,\r\n            new Error(`Cannot send; invalid websocket state=${this.ws?.readyState ?? '[no connection]'}`)\r\n        );\r\n    }\r\n\r\n    private onMessage(event: MessageEvent): void {\r\n        const envelope: Envelope = JSON.parse(event.data);\r\n        this.handleIncomingEnvelope(envelope);\r\n        this.emit(envelope.type, envelope.data);\r\n        this.emit(this.Event.message, envelope);\r\n\r\n        // Login successfully\r\n        if (!this.authenticated) {\r\n            const isAuthenticated = envelope.type !== 'Bye';\r\n            this.authenticated = isAuthenticated;\r\n            if (isAuthenticated) {\r\n                this.authenticatedResolvers[0]();\r\n                this.emit(this.Event.connect);\r\n                this.sendFromQueue();\r\n            } else {\r\n                this.authenticatedResolvers[1](envelope.data);\r\n            }\r\n        }\r\n    }\r\n\r\n    private onClose(event: CloseEvent): void {\r\n        clearTimeout(this.connectingTimeoutId);\r\n        const reconnect = event.code !== 1000; // Connection was closed because of error\r\n        if (reconnect) {\r\n            void this.connect();\r\n        }\r\n        this.emit(this.Event.disconnect, reconnect);\r\n    }\r\n\r\n    private sendFromQueue(): void {\r\n        // Send awaiting data to server\r\n        let lastDelay = 0;\r\n        for (const dataIndex in this.sendQueue) {\r\n            const envelope = this.sendQueue[dataIndex];\r\n            setTimeout(() => this.sendEnvelope(envelope), lastDelay);\r\n            lastDelay += this.options.awaitQueueSendDelayMs ?? 500;\r\n        }\r\n        this.sendQueue = [];\r\n        clearTimeout(this.connectingTimeoutId);\r\n    }\r\n\r\n    private triggerConnectionTimeout(): void {\r\n        this.disconnect();\r\n        this.emit(this.Event.error, new Error('Connection timeout'));\r\n    }\r\n\r\n    private isPendingReadyWsState(): boolean {\r\n        return this.ws && this.ws.readyState === this.ws.CONNECTING || !this.authenticated;\r\n    }\r\n\r\n    private isReadyToSendWsState(): boolean {\r\n        return this.ws && this.ws.readyState === this.ws.OPEN && this.authenticated;\r\n    }\r\n}","import {AbstractChatClient, CommandResult, CommandsMap} from \"./AbstractChatClient\";\r\nimport {ObservableInterface} from \"./EventTarget\";\r\nimport {Envelope} from \"./types/src\";\r\n\r\nexport interface WebApiChatClientOptions {\r\n    url: string;\r\n    token: string;\r\n    attemptsToSend?: number;\r\n    attemptDelayMs?: number;\r\n    queryParams?: Record<string, string>;\r\n}\r\n\r\nenum WebApiChatClientEvent {\r\n    message = 'message',\r\n    error = 'error',\r\n    destroy = 'destroy',\r\n}\r\n\r\nexport class WebApiChatClient extends AbstractChatClient implements ObservableInterface {\r\n    public readonly Event = WebApiChatClientEvent;\r\n\r\n    protected sendStack: {data: any, attempts: number, lastTimeoutId: any}[];\r\n\r\n    public constructor(private readonly options: WebApiChatClientOptions) {\r\n        super();\r\n    }\r\n\r\n    public async send<CommandType extends keyof CommandsMap>(commandType: CommandType, commandData: CommandsMap[CommandType][0]):\r\n        Promise<CommandResult<CommandsMap[CommandType][1]>> {\r\n        const envelope = this.createEnvelope(commandType, commandData);\r\n        this.sendStack.push({data: envelope, attempts: 0, lastTimeoutId: null});\r\n        this.makeApiCall(this.sendStack.length - 1);\r\n        return this.createPromiseFromCommandEnvelope(envelope);\r\n    }\r\n\r\n    public destroy(): void {\r\n        // Cancel all awaiting requests\r\n        this.sendStack.forEach(item => {\r\n            if (item.lastTimeoutId) {\r\n                clearTimeout(item.lastTimeoutId);\r\n            }\r\n            this.awaitingResponse.delete(item.data.ref);\r\n        });\r\n        this.sendStack = [];\r\n        this.emit(this.Event.destroy, false);\r\n    }\r\n\r\n    protected async onMessage(reqId: number, response: Response): Promise<void> {\r\n        this.sendStack.splice(reqId, 1);\r\n        const envelope: Envelope = await response.json();\r\n        this.handleIncomingEnvelope(envelope);\r\n        this.emit(envelope.type, envelope.data);\r\n        this.emit(this.Event.message, envelope);\r\n    }\r\n\r\n    protected onError(reqId: number, body: string): void {\r\n        if (this.sendStack[reqId].attempts >= (this.options.attemptsToSend ?? 10)) {\r\n            this.sendStack.splice(reqId, 1);\r\n            this.handleEnvelopeSendError(this.sendStack[reqId].data, new Error(\r\n                `Cannot send ${body}; aborting after reaching the maximum connection errors`\r\n            ));\r\n            return;\r\n        }\r\n        this.sendStack[reqId].lastTimeoutId = setTimeout(\r\n            () => this.makeApiCall(reqId),\r\n            this.options.attemptDelayMs ?? 3000\r\n        );\r\n    }\r\n\r\n    protected makeApiCall(reqId: number): void {\r\n        this.sendStack[reqId].attempts++;\r\n        const bodyJson = JSON.stringify(this.sendStack[reqId].data);\r\n        const headers: any = {\r\n            'Content-Type': 'application/json',\r\n            Accept: 'application/json'\r\n        };\r\n\r\n        headers.Authorization = `Bearer ${this.options.token}`;\r\n\r\n        const params = new URLSearchParams(this.options.queryParams ?? {});\r\n        const url = `${this.options.url}${params ? '?' + params : ''}`;\r\n\r\n        fetch(url, {\r\n            headers,\r\n            body: bodyJson,\r\n            method: 'POST',\r\n        })\r\n            .then(response => this.onMessage(reqId, response))\r\n            .catch(() => this.onError(reqId, bodyJson));\r\n    }\r\n}","export interface RestClientOptions {\r\n    url?: string;\r\n    token: string;\r\n}\r\n\r\nexport interface RestClientResponse<T> {\r\n    ok: boolean;\r\n    status: number;\r\n    data: T;\r\n}\r\n\r\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\r\n\r\nexport abstract class AbstractRestClient {\r\n    protected abstract defaultUrl: string;\r\n\r\n    public constructor(\r\n        private readonly options: RestClientOptions,\r\n    ) {}\r\n\r\n    protected async send<ResponseT = any>(\r\n        method: HttpMethod,\r\n        uri: string,\r\n        data: any = undefined\r\n    ): Promise<RestClientResponse<ResponseT>> {\r\n        let url = this.getUrl(uri);\r\n        let body = undefined;\r\n\r\n        if (data) {\r\n            if (['GET', 'DELETE'].includes(method)) {\r\n                url += new URLSearchParams(data).toString()\r\n            } else {\r\n                body = JSON.stringify(data);\r\n            }\r\n        }\r\n\r\n        const headers = {\r\n            'Content-Type': 'application/json',\r\n            Accept: 'application/json',\r\n            ...this.getAuthHeaders(),\r\n        };\r\n\r\n        const result = await fetch(url, {method, body, headers});\r\n\r\n        return this.convertFetchResponse(result);\r\n    }\r\n\r\n    protected getAuthHeaders(): any {\r\n        const headers = {} as any;\r\n\r\n        if (this.options.token) {\r\n            headers.Authorization = `Bearer ${this.options.token}`;\r\n        }\r\n\r\n        return headers;\r\n    }\r\n\r\n    protected getUrl(uri: string): string {\r\n        return this.removeEndingSlash(this.options.url ?? this.defaultUrl) + '/' + this.removeStartingSlash(uri);\r\n    }\r\n\r\n    protected async convertFetchResponse<T>(result: Response): Promise<RestClientResponse<T>> {\r\n        return {\r\n            ok: result.ok,\r\n            status: result.status,\r\n            data: result.headers.get('content-type')?.includes('json') ? await result.json() : await result.text(),\r\n        };\r\n    }\r\n\r\n    private removeStartingSlash(text: string): string {\r\n        return text.replace(/^\\/+/, '');\r\n    }\r\n\r\n    private removeEndingSlash(text: string): string {\r\n        return text.replace(/\\/+$/, '');\r\n    }\r\n}","import {AbstractRestClient} from \"./AbstractRestClient\";\r\n\r\nexport interface TokenInterface {\r\n    token: string,\r\n    expiration: string\r\n}\r\n\r\nexport interface MyAccountInterface {\r\n    id: string;\r\n    nick: string;\r\n    avatar: string;\r\n}\r\n\r\nexport class AuthClient extends AbstractRestClient {\r\n    protected defaultUrl: string = 'https://polfan.pl/webservice/api';\r\n\r\n    public static async createToken(\r\n        login: string,\r\n        password: string,\r\n        clientName: string = 'pserv-js-client'\r\n    ): Promise<TokenInterface> {\r\n        const response = await new AuthClient({token: null}).send('POST', 'auth/tokens', {\r\n            login, password, client_name: clientName\r\n        });\r\n        if (response.ok) {\r\n            return response.data;\r\n        }\r\n        throw new Error(`Cannot create user token: ${response.data.errors[0]}`);\r\n    }\r\n\r\n    public async deleteToken(token: string): Promise<void> {\r\n        const response = await this.send('DELETE', `auth/tokens/${token}`);\r\n        if (!response.ok) {\r\n            throw new Error(`Cannot delete access token: ${response.data.errors[0]}`);\r\n        }\r\n    }\r\n\r\n    public async getMe(): Promise<MyAccountInterface> {\r\n        const response = await this.send('GET', 'auth/me');\r\n        if (response.ok) {\r\n            response.data.id = response.data.id.toString();\r\n            return response.data;\r\n        }\r\n        throw new Error(`Cannot get current user account: ${response.data.errors[0]}`);\r\n    }\r\n}","import {AbstractRestClient, RestClientResponse} from \"./AbstractRestClient\";\r\n\r\nexport interface File {\r\n    id: string;\r\n    url: string;\r\n    name: string;\r\n    mime: string;\r\n    size: number;\r\n    width?: number;\r\n    height?: number;\r\n}\r\n\r\nexport class FilesClient extends AbstractRestClient {\r\n    protected defaultUrl: string = 'https://files.devana.pl';\r\n\r\n    public async uploadFile(file: globalThis.File | Blob): Promise<RestClientResponse<File>> {\r\n        const name = encodeURIComponent((file as globalThis.File).name ?? '');\r\n        let headers = {\r\n            ...this.getAuthHeaders(),\r\n            Accept: 'application/json',\r\n            'Content-Disposition': `attachment; filename=\"${name}\"`,\r\n            'Content-Length': file.size\r\n        };\r\n\r\n        const response = await fetch(this.getUrl('files'), {\r\n            method: 'POST',\r\n            body: file,\r\n            headers\r\n        });\r\n\r\n        return this.convertFetchResponse<File>(response);\r\n    }\r\n\r\n    public async getFileMeta(id: string): Promise<RestClientResponse<File>> {\r\n        return this.send('GET', 'files/' + id);\r\n    }\r\n\r\n    public async getFileMetaBulk(ids: string[]): Promise<RestClientResponse<File[]>> {\r\n        const searchParams = new URLSearchParams();\r\n        ids.forEach(id => searchParams.append('id[]', id));\r\n        return this.send('GET', 'files?' + searchParams);\r\n    }\r\n}"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","EventTarget","constructor","_defineProperty","Map","on","eventName","handler","addHandler","events","once","onceEvents","off","_this$events$get","index","indexOf","splice","emit","event","callHandlers","delete","map","_map$get","handlers","push","set","_map$get2","forEach","callback","AbstractChatClient","arguments","super","createEnvelope","type","data","ref","sentCounter","toString","createPromiseFromCommandEnvelope","envelope","_this","Promise","_len","length","args","Array","_key","awaitingResponse","handleIncomingEnvelope","has","isError","error","handleEnvelopeSendError","IndexedCollection","items","undefined","_items","size","item","id","_len2","ids","_key2","deleteAll","clear","findBy","field","valueToFind","limit","result","entries","next","done","shallowCopy","copy","IndexedObjectCollection","from","values","_len3","_key3","getId","getAt","ObservableIndexedCollection","eventTarget","_len4","_key4","setItems","_len5","_key5","deletedItems","keys","ObservableIndexedObjectCollection","_len6","_key6","_len7","_key7","DeferredTask","promise","resolve","PromiseRegistry","register","promises","registerByFunction","fn","notExist","forget","forgetAll","WindowState","TraversableRemoteCollection","LIVE","state","currentState","hasLatest","LATEST","includes","hasOldest","OLDEST","oldestId","resetToLatest","_asyncToGenerator","fetchingState","fetchLatestItems","addItems","fetchPrevious","_this2","PAST","fetchItemsBefore","firstItem","refreshFetchedState","fetchNext","_this3","fetchItemsAfter","_this4","isLatestItemLoaded","newItems","to","trimItemsArrayToLimit","slice","TopicHistoryWindow","roomId","topicId","tracker","client","ev","handleSession","handleNewMessage","isTraverseLocked","traverseLock","setTraverseLock","lock","_superprop_getResetToLatest","_this5","_superprop_getResetToLatest2","_this6","_superprop_getFetchNext","_this7","_superprop_getFetchPrevious","_this8","_updateMessageReference","refTopic","refMessage","_objectSpread","topicRef","_this9","message","location","rooms","find","room","_this0","_this0$getAt","afterId","send","after","Error","concat","messages","_this1","_this1$getAt","beforeId","before","_this10","getTopic","_this11","getTopics","getLatestMessageId","_this12","_yield$_this12$getTop","_yield$_this12$getTop2","lastMessage","_this13","lastMessageId","RoomMessagesHistory","handleRoomUpdated","handleNewTopic","handleTopicDeleted","updateTraverseLock","defaultTopic","createHistoryWindowForTopic","getMessagesWindow","historyWindows","topic","window","historyWindow","refHistoryWindow","history","mode","MessagesManager","handleRoomJoin","handleFollowedTopicUpdated","handleTopicFollowed","handleTopicUnfollowed","handleRoomDeleted","handleRoomLeft","getRoomHistory","deferredSession","roomHistories","cacheSpaceFollowedTopics","spaceId","spaces","roomIds","resultPromise","followedTopicsPromises","setFollowedTopicsArray","followedTopics","getRoomFollowedTopics","ackRoomFollowedTopics","collection","followedTopic","missed","calculateRoomMissedMessages","reduce","previousValue","currentValue","_currentValue$missed","_deleteByTopicIds","_this$followedTopics$","topicIds","createHistoryForNewRoom","updateLocallyFollowedTopicOnNewMessage","_this$followedTopics$2","_this$followedTopics$3","clearRoomFollowedTopicsStructures","_this$followedTopics$4","_this$tracker$me","update","roomFollowedTopics","author","user","me","lastAckMessageId","roomToTopics","_followedTopic$locati","_roomToTopics$_follow","RoomsManager","handleRoomJoined","handleTopicUpdated","handleRoomMemberJoined","handleRoomMemberLeft","handleRoomMembers","handleRoomMemberUpdated","handleSpaceMemberLeft","handleSpaceMemberUpdated","handleSpaceDeleted","handleUserUpdated","getMembers","membersPromises","members","getMe","userId","list","member","_member$user$id","_member$user","spaceMember","tryToFetchTopicIds","idsToFetch","filter","_this4$topics$get","topics","topicsPromises","then","_this4$topics$get2","deleteRoom","_this$topics$get$item","_this$topics$get","deleteRoomsBySpaceId","roomMembers","roomMember","_this$members$get","_member$spaceMember$u","_member$spaceMember","newMember","_room$defaultTopic","addJoinedRoomTopics","addJoinedRooms","_this$topics$get2","recipients","roles","_member$user$id2","_member$user2","newRooms","_room$recipients","some","_room$defaultTopic2","newTopic","messageCount","extractUserFromMember","_spaceMember","SpacesManager","handleNewRoom","handleSpaceUpdated","handleSpaceJoined","handleSpaceMemberJoined","handleSpaceMembers","handleSpaceRooms","handleRoomSummaryUpdated","handleNewRole","handleRoleDeleted","handleRoleUpdated","getRoles","getRooms","roomsPromises","role","_this$rooms$get","summary","roomIdToSpaceId","name","description","_this6$rooms$get","space","spaceChanged","systemRoom","defaultRooms","_this$rooms$get$items","_this$rooms$get2","addJoinedSpaces","summaries","summariesPromise","newSummary","oldSummary","oldRole","newRole","rolesToUpdate","priority","allRoles","updatedRole","increased","decreased","changedRoles","reorderRolesOnPriorityUpdate","Layer","PermissionDefinition","Permissions","permissionName","layer","getByName","maxLayer","Root","Room","CreateSpaces","Global","ManageSpace","Space","ManageSpaceRoles","ManageRoom","CreateTopics","ManageTopic","Topic","ManageSpaceMembers","ManageRoomMembers","CreateMessages","ManagePermissions","CreateSpaceRooms","ManageSpaceRooms","CreateEmoticons","ManageEmoticon","ManageBan","Kick","ChangeOwnNick","getOvId","target","roleId","Boolean","join","getOvIdByObject","overwrites","PermissionsManager","handlePermissionOverwrites","getOverwrites","validateLocation","overwritesPromises","check","permissionNames","ownedPermissions","calculatePermissions","missing","ok","hasAll","hasAny","_spaceMember$roles","_roomMember$roles","_yield$_this3$tracker","_yield$_this3$tracker2","_yield$_this3$tracker3","fetchMembersOrFail","userRoles","v","filterLocation","collectRoleOverwrites","resolveOverwritesHierarchy","all","deleteOverwritesByIdPrefix","_this$tracker$me2","prefix","startsWith","roleOverwrites","resolveOverwritesFromRolesByOrder","allows","denies","sortedOverwrites","sort","a","b","permissionsLength","_currentValue$overwri","_currentValue$overwri2","_currentValue$overwri3","_currentValue$overwri4","Math","max","allow","deny","overwriteEvent","_overwrites$deny$toSt","_overwrites$deny","_overwrites$allow$toS","_overwrites$allow","revDecDenies","split","reverse","revDecAllows","i","_revDecDenies$i","_revDecAllows$i","parseInt","permissionOverwritesValues","getRootAccessValue","getNames","results","spaceFail","roomFail","GLOBAL_KEY","EmoticonsManager","handleEmoticons","handleNewEmoticon","handleEmoticonDeleted","emoticonsPromises","_event$location$space","emoticons","_ev$emoticon$spaceId","emoticon","_ev$spaceId","emoticonId","UsersManager","handleUsers","handleMembers","getAvailable","users","session","newUser","oldUser","online","onlineStatus","refUserId","getIdFromRelationship","relationship","refUser","RelationshipsManager","handleRelationships","handleNewRelationship","handleRelationshipDeleted","relationships","exists","ChatStateTracker","_me","WebSocketChatClientEvent","WebSocketChatClient","options","_this$options$stateTr","stateTracking","connect","_this$options$queryPa","_this$options$connect","params","URLSearchParams","queryParams","token","ws","WebSocket","url","onclose","onClose","onmessage","onMessage","connectingTimeoutId","setTimeout","triggerConnectionTimeout","connectingTimeoutMs","authenticated","authenticatedResolvers","disconnect","_this$ws","sendQueue","close","commandType","commandData","isPendingReadyWsState","sendEnvelope","_this$ws$readyState","_this$ws2","isReadyToSendWsState","JSON","stringify","readyState","parse","Event","isAuthenticated","sendFromQueue","clearTimeout","reconnect","code","lastDelay","_loop","dataIndex","_this3$options$awaitQ","awaitQueueSendDelayMs","CONNECTING","OPEN","WebApiChatClientEvent","WebApiChatClient","sendStack","attempts","lastTimeoutId","makeApiCall","destroy","reqId","response","json","onError","body","_this$options$attempt","_this$options$attempt2","attemptsToSend","attemptDelayMs","bodyJson","headers","Accept","Authorization","fetch","method","catch","AbstractRestClient","uri","_arguments","getUrl","getAuthHeaders","convertFetchResponse","_this$options$url","removeEndingSlash","defaultUrl","removeStartingSlash","_result$headers$get","status","text","replace","AuthClient","login","password","clientName","client_name","errors","deleteToken","FilesClient","uploadFile","file","_name","encodeURIComponent","getFileMeta","getFileMetaBulk","searchParams","append"],"sourceRoot":""}